{"title":"Intersection Observer 交叉观察","uid":"13f6ca6756a4b641116bd6f0d8205d5e","slug":"intersection-observer","date":"2022-10-15T10:45:36.000Z","updated":"2024-10-09T13:08:15.158Z","comments":true,"path":"api/articles/intersection-observer.json","keywords":null,"cover":"/images/cover1.jpg","content":"<p>IntersectionObserver API 是现代浏览器提供的一种异步观察目标元素与祖先元素（或顶级文档视窗）交叉状态的方法。它可以用于实现懒加载图片、无限滚动、以及其他需要监听元素可见性的功能。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>在开始使用 IntersectionObserver 之前，我们需要了解几个基本概念：</p>\n<p>目标元素（Target Element）：你想要观察的元素。<br>根元素（Root Element）：用来检测目标元素的可见性变化的容器元素，默认为浏览器视窗。<br>阈值（Threshold）：触发回调函数的目标元素可见比例。</p>\n<h3 id=\"为什么使用-IntersectionObserver\"><a href=\"#为什么使用-IntersectionObserver\" class=\"headerlink\" title=\"为什么使用 IntersectionObserver\"></a>为什么使用 IntersectionObserver</h3><p>传统上，我们会使用 scroll 事件监听元素的可见性变化。然而，这种方法有几个缺点：</p>\n<p>性能问题：滚动事件会频繁触发，从而导致性能问题。<br>复杂的计算：需要手动计算元素的可见性。<br>IntersectionObserver 可以解决这些问题：<br>性能更好：IntersectionObserver 是异步的，不会频繁触发。<br>简单易用：只需要定义一次观察逻辑，浏览器会处理所有计算。</p>\n<h3 id=\"创建-IntersectionObserver-实例\"><a href=\"#创建-IntersectionObserver-实例\" class=\"headerlink\" title=\"创建 IntersectionObserver 实例\"></a>创建 IntersectionObserver 实例</h3><p>IntersectionObserver 是一个构造函数，我们需要先创建一个实例。构造函数接收两个参数：回调函数和可选配置对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> options = &#123;</span><br><span class=\"line\">  <span class=\"attr\">root</span>: <span class=\"literal\">null</span>, <span class=\"comment\">// 默认为视窗</span></span><br><span class=\"line\">  <span class=\"attr\">rootMargin</span>: <span class=\"string\">&#x27;0px&#x27;</span>, <span class=\"comment\">// 视窗的外边距</span></span><br><span class=\"line\">  <span class=\"attr\">threshold</span>: <span class=\"number\">0.1</span> <span class=\"comment\">// 目标元素可见比例达到 10% 时触发回调</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ob = <span class=\"keyword\">new</span> <span class=\"title class_\">IntersectionObserver</span>(listener, options);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定义回调函数\"><a href=\"#定义回调函数\" class=\"headerlink\" title=\"定义回调函数\"></a>定义回调函数</h3><p>回调函数在目标元素的可见性变化时被调用。它接收两个参数：entries 和 observer。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">listener</span> = (<span class=\"params\">entries, observer</span>) =&gt; &#123;</span><br><span class=\"line\">  entries.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">entry</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry.<span class=\"property\">isIntersecting</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;目标元素进入视窗&#x27;</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 在此处理进入视窗后的逻辑</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;目标元素离开视窗&#x27;</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 在此处理离开视窗后的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"观察目标元素\"><a href=\"#观察目标元素\" class=\"headerlink\" title=\"观察目标元素\"></a>观察目标元素</h3><p>创建 IntersectionObserver 实例后，使用 observe 方法开始观察目标元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> imgs = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">&quot;img[data-src]&quot;</span>);</span><br><span class=\"line\">imgs.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">img</span>)=&gt;</span> &#123;</span><br><span class=\"line\">  ob.<span class=\"title function_\">observe</span>(img)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"停止观察\"><a href=\"#停止观察\" class=\"headerlink\" title=\"停止观察\"></a>停止观察</h3><p>如果不再需要观察某个元素，可以使用 unobserve 方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">observer.<span class=\"title function_\">unobserve</span>(target);</span><br></pre></td></tr></table></figure>\n\n<p>当不再需要 IntersectionObserver 实例时，可以调用 disconnect 方法停止观察所有目标元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">observer.<span class=\"title function_\">disconnect</span>();</span><br></pre></td></tr></table></figure>\n\n<p>完整例子：</p>\n<p><a href=\"https://codepen.io/yongqimeng/pen/YzoYMxm?editors=1010\">图片懒加载codepen</a></p>\n","text":"IntersectionObserver API 是现代浏览器提供的一种异步观察目标元素与祖先元素（或顶级文档视窗）交叉状态的方法。它可以用于实现懒加载图片、无...","permalink":"/post/intersection-observer","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"javascript","slug":"javascript","count":8,"path":"api/categories/javascript.json"}],"tags":[{"name":"Web API","slug":"Web-API","count":5,"path":"api/tags/Web-API.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-IntersectionObserver\"><span class=\"toc-text\">为什么使用 IntersectionObserver</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA-IntersectionObserver-%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">创建 IntersectionObserver 实例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">定义回调函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E7%9B%AE%E6%A0%87%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">观察目标元素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%81%9C%E6%AD%A2%E8%A7%82%E5%AF%9F\"><span class=\"toc-text\">停止观察</span></a></li></ol>","author":{"name":"M","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"这是我的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"getBoundingClientRect","uid":"c40fd8eb89666f7ca7e92e2c34687b74","slug":"getBoundingClientRect","date":"2022-12-17T08:49:36.000Z","updated":"2024-10-09T13:32:13.383Z","comments":true,"path":"api/articles/getBoundingClientRect.json","keywords":null,"cover":"/images/cover1.jpg","text":"Element.getBoundingClientRect() 方法返回一个 DOMRect 对象，其提供了元素的大小及其相对于视口的位置，指元素(宽高必须设置...","permalink":"/post/getBoundingClientRect","photos":[],"count_time":{"symbolsCount":665,"symbolsTime":"1 mins."},"categories":[{"name":"javascript","slug":"javascript","count":8,"path":"api/categories/javascript.json"}],"tags":[{"name":"Web API","slug":"Web-API","count":5,"path":"api/tags/Web-API.json"}],"author":{"name":"M","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"这是我的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"简单的数字变化动画","uid":"05fa6aa6edf6aaca899b62885f8a8f70","slug":"count-number","date":"2022-09-18T04:59:08.000Z","updated":"2024-10-09T13:05:05.540Z","comments":true,"path":"api/articles/count-number.json","keywords":null,"cover":"/images/cover1.jpg","text":"记录一个简单的数字变化动画 function animation({ from, to, duration = 1000, onUpdate }) { let ...","permalink":"/post/count-number","photos":[],"count_time":{"symbolsCount":533,"symbolsTime":"1 mins."},"categories":[{"name":"javascript","slug":"javascript","count":8,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":1,"path":"api/tags/javascript.json"}],"author":{"name":"M","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"这是我的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}