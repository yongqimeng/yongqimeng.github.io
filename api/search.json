[{"id":"5ec98a85a99b57e340a9a2a9ff61c2c1","title":"封装canvas画分享图能力","content":"整理了一下工作中封装的画分享海报的能力\nclass ShareCanvas &#123;    constructor(config) &#123;        this.width = config.width || 375;        this.height = config.height || 616;        this.scale = config.scale || 3;        this.canvasDom = document.createElement(&#x27;canvas&#x27;);        this.ctx = this.canvasDom.getContext(&#x27;2d&#x27;);        this.canvasDom.width = this.width * this.scale;        this.canvasDom.height = this.height * this.scale;        if (!config?.hidden) &#123;            document.body.appendChild(this.canvasDom);        &#125;    &#125;    /**     *     * url  图片url     * x x轴     * y  y轴     * width 图片宽度     * height 图片高     * radius  传值则画圆角图片     * rotate 旋转     */    drawImg(config) &#123;        let promise = new Promise((resolve, reject) =&gt; &#123;            let img = new Image();            img.onload = () =&gt; &#123;                if (config.bgColor) &#123;                    this.ctx.fillStyle = config.bgColor;                    this.ctx.fillRect(0, 0, config.x * this.scale, config.y * this.scale);                    this.ctx.restore();                    return;                &#125;                this.ctx.save();                if (config.filter) &#123;                    this.ctx.filter = config.filter;                &#125;                if (config.opacity) &#123;                    this.ctx.globalAlpha = config.opacity;                &#125;                if (config.radius) &#123;                    // 传radius可画圆角头像                    config.radius = config.radius * this.scale;                    config.x = config.x * this.scale;                    config.y = config.y * this.scale;                    // this.ctx.save();                    this.ctx.beginPath();                    const size = 2 * config.radius;                    this.ctx.arc(config.x, config.y, config.radius, 0, 2 * Math.PI);                    this.ctx.clip();                    this.ctx.drawImage(img, (config.x - config.radius), (config.y - config.radius), size, size);                    // this.ctx.restore();                &#125; else &#123;                    if(config.rotate) &#123;                        let rotateX = config.x;                        let rotateY = config.y;                        let offsetX = 0;                        let offsetY = 0;                        // 围绕图片中心点旋转                        if (config.rotateAroundCenter) &#123;                            offsetX = config.width / 2;                            offsetY = config.height / 2;                            rotateX += offsetX;                            rotateY += offsetY;                        &#125;                        this.ctx.save();                        this.ctx.translate(rotateX * this.scale, rotateY * this.scale);                        this.ctx.rotate(config.rotate * Math.PI / 180);                        this.drawBorderRadius(config);                        this.ctx.drawImage(img, -offsetX, -offsetY, (config.width || this.width) * this.scale, (config.height || this.height) * this.scale);                        this.ctx.setTransform(1, 0, 0, 1, 0, 0);                        // this.ctx.restore();                    &#125; else &#123;                        this.drawBorderRadius(config);                        this.ctx.drawImage(img, config.x * this.scale, config.y * this.scale, (config.width || this.width) * this.scale, (config.height || this.height) * this.scale);                    &#125;                &#125;                this.ctx.restore();                resolve();            &#125;;            img.onerror = (e) =&gt; &#123;                reject(e);            &#125;;            img.setAttribute(&#x27;crossOrigin&#x27;, &#x27;anonymous&#x27;);            img.src = config.url;        &#125;);        return promise;    &#125;    drawTextWithShadow(cssStyle, text, x, y) &#123;        // 解析CSS样式        const styleParts = cssStyle.split(&#x27;,&#x27;).map((part) =&gt; part.trim());        const shadowStyles = styleParts.map((part) =&gt; &#123;            const [offsetX, offsetY, color] = part.split(&#x27; &#x27;);            return &#123;                offsetX: parseFloat(offsetX),                offsetY: parseFloat(offsetY),                color,            &#125;;        &#125;);        // 绘制字体描边        shadowStyles.forEach((style) =&gt; &#123;            this.ctx.shadowOffsetX = style.offsetX;            this.ctx.shadowOffsetY = style.offsetY;            this.ctx.shadowColor = style.color;            this.ctx.fillText(text, x, y);        &#125;);        // 绘制字体本身        this.ctx.shadowColor = &#x27;transparent&#x27;; // 清除阴影设置        this.ctx.fillText(text, x, y);        // this.ctx.restore();    &#125;    drawBorderRadius(config) &#123;        if (config.border_radius) &#123;            // 绘制圆角图片            const borderRadius = config.border_radius;            const x = config.x;            const y = config.y;            const width = config.width;            const height = config.height;            // this.ctx.save();            this.ctx.beginPath();            this.ctx.moveTo(x + borderRadius, y);            this.ctx.lineTo(x + width - borderRadius, y);            this.ctx.arcTo(x + width, y, x + width, y + borderRadius, borderRadius);            this.ctx.lineTo(x + width, y + height - borderRadius);            this.ctx.arcTo(x + width, y + height, x + width - borderRadius, y + height, borderRadius);            this.ctx.lineTo(x + borderRadius, y + height);            this.ctx.arcTo(x, y + height, x, y + height - borderRadius, borderRadius);            this.ctx.lineTo(x, y + borderRadius);            this.ctx.arcTo(x, y, x + borderRadius, y, borderRadius);            this.ctx.closePath();            this.ctx.clip();            // this.ctx.restore();        &#125;    &#125;    filterText(str, width, x, y, fixedText = &#x27;&#x27;, tail = 10, isStroke, right, bottom, textShadow) &#123;        const widthBox = (width || this.width) * this.scale;        const fixedTextWidth = this.ctx.measureText(fixedText).width;        let maxWidth = (widthBox - (tail * this.scale)) - fixedTextWidth;        let strWidth = this.ctx.measureText(str).width;        const ellipsis = &#x27;... &#x27;;        const ellipsisWidth = this.ctx.measureText(ellipsis).width;        let text = &#x27;&#x27;;        if (strWidth &lt;= maxWidth || maxWidth &lt;= ellipsisWidth) &#123;            text = str + fixedText;        &#125; else &#123;            let len = str.length;            while (strWidth &gt;= maxWidth - ellipsisWidth &amp;&amp; len-- &gt; 0) &#123;                str = str.slice(0, len);                strWidth = this.ctx.measureText(str).width;            &#125;            text = str + ellipsis + fixedText;        &#125;        let finalX = x * this.scale;        let finalY = y * this.scale;        // 没有传x且传了right, 就按right去定位        if (!x &amp;&amp; right) &#123;            finalX = widthBox - right;        &#125;        // 没有传y且传了bottom, 就按bottom去定位        if (!y &amp;&amp; bottom) &#123;            finalY = this.height * this.scale - bottom;        &#125;        if (textShadow) &#123;            this.drawTextWithShadow(textShadow, text, finalX, finalY);        &#125; else if (isStroke) &#123;            this.ctx.fillText(text, finalX, finalY);            this.ctx.strokeText(text, finalX, finalY);        &#125; else &#123;            this.ctx.fillText(text, finalX, finalY);        &#125;        this.ctx.restore();        return text;    &#125;    filterMultiLineText(config, x, y, isStroke) &#123;        const &#123; lineHeight, text, lineLimit, fontSize, whiteSpace, textShadow &#125; = config || &#123;&#125;;        if (!lineHeight) return;        let textRows = [];        if (whiteSpace &amp;&amp; whiteSpace.indexOf(&#x27;pre&#x27;) !== -1) &#123;            textRows = text.split(&#x27;\\n&#x27;);        &#125; else if (lineLimit) &#123;            for (let i = 0; i &lt; text.length; i += lineLimit) &#123;                textRows.push(text.substring(i, i + lineLimit));            &#125;        &#125;        const finalX = x * this.scale;        let finalY = (y - fontSize) * this.scale;        for (let i = 0; i &lt; textRows.length; i++) &#123;            const line = textRows[i];            this.ctx.textBaseline = &#x27;top&#x27;;            if (textShadow) &#123;                this.drawTextWithShadow(textShadow, line, finalX, finalY);            &#125; else if (isStroke) &#123;                this.ctx.fillText(line, finalX, finalY);                this.ctx.strokeText(line, finalX, finalY);            &#125; else &#123;                this.ctx.fillText(line, finalX, finalY);            &#125;            finalY += lineHeight * this.scale;        &#125;        this.ctx.restore();        return text;    &#125;    /**        text: 文字        x: x轴        y: y轴        right: 距离右边的距离        bottom: 距离下边的距离        width: 文字宽度        color: 文字颜色        fontSize: 文字大小        strokeColor: 描边颜色        lineWidth: 描边宽度        fontFamily: 字体        fontBold: 字体是否加粗        textAlign: 文字对齐方式        lineHeight: 行高        shadowColor: 文字阴影颜色        shadowOffsetX: 文字阴影x轴        shadowOffsetY: 文字阴影y轴        shadowBlur: 文字阴影模糊        letterSpacing 文字间距        rotate 旋转    */    strokeText(config) &#123;        const textAlign = config.textAlign || &#x27;center&#x27;;        // 当x为0或者未传时，重新设置x，使文字能在容器内呈现与html css样式一样的效果        // 不重写的话，当x为0，textaligh为center时，文字将超出屏幕只画一半        const finalWidth = config.width || this.width * this.scale;        const &#123; bottom, right, rotate &#125; = config;        let finalX = config.x;        let finalY = config.y;        if (!finalX &amp;&amp; !right) &#123;            if (textAlign === &#x27;center&#x27;) &#123;                finalX = finalWidth / 2;            &#125; else if (textAlign === &#x27;right&#x27;) &#123;                finalX = finalWidth;            &#125;        &#125;        this.ctx.textAlign = textAlign ;        this.ctx.save();        if (rotate) &#123;            this.ctx.translate(finalX, finalY);            this.ctx.rotate(rotate * Math.PI / 180);            finalX = 0;            finalY = 0;        &#125;        if (config.strokeColor) &#123;            this.ctx.strokeStyle = config.strokeColor;            this.ctx.lineWidth = config.lineWidth;            this.ctx.font = `$&#123;config.fontBold || &#x27;400&#x27;&#125; $&#123;(config.fontSize || 17) * this.scale&#125;px $&#123;config.fontFamily || &#x27;PingFang SC&#x27;&#125;`;            this.ctx.fillStyle = config.color || &#x27;rgba(255, 255, 255, 1)&#x27;;            if (config.lineHeight || config.whiteSpace === &#x27;pre&#x27;) &#123;                this.filterMultiLineText(config, finalX, finalY, true);            &#125; else &#123;                this.filterText(config.text, finalWidth, finalX, finalY, &#x27;&#x27;, 10, true, right, bottom, config.textShadow);            &#125;        &#125; else &#123;            if (config.shadowColor) &#123;                const &#123; shadowColor, shadowOffsetX, shadowOffsetY, shadowBlur &#125; = config;                this.ctx.shadowColor = shadowColor;                this.ctx.shadowOffsetX = shadowOffsetX;                this.ctx.shadowOffsetY = shadowOffsetY;                this.ctx.shadowBlur = shadowBlur;            &#125;;            this.ctx.fillStyle = config.color || &#x27;rgba(255, 255, 255, 1)&#x27;;            this.canvasDom.style.letterSpacing = config.letterSpacing || &#x27;0px&#x27;;            this.ctx.font = `$&#123;config.fontBold || &#x27;400&#x27;&#125; $&#123;(config.fontSize || 17) * this.scale&#125;px $&#123;config.fontFamily || &#x27;PingFang SC&#x27;&#125;`;            if (config.lineHeight || config.whiteSpace === &#x27;pre&#x27;) &#123;                this.filterMultiLineText(config, finalX, finalY, false);            &#125; else &#123;                this.filterText(config.text, finalWidth, finalX, finalY, &#x27;&#x27;, 10, false, right, bottom, config.textShadow);            &#125;        &#125;    &#125;    /**        x: x轴        y: y轴        width: 矩形宽度        height: 文字颜色        radius: 矩形的圆角        linewidth: 描边宽度        fillColor: 填充颜色        strokeColor: 描边颜色    */    roundReact(reactConfig) &#123;        // 圆角矩形        const x = reactConfig.x * this.scale;        const y = reactConfig.y * this.scale;        const width = reactConfig.width * this.scale;        const height = reactConfig.height * this.scale;        const radius = (reactConfig.radius || 0) * this.scale;        this.ctx.beginPath();        this.ctx.lineWidth = (reactConfig.lineWidth || 0) * this.scale;        this.ctx.moveTo(x + radius, y);        this.ctx.lineTo(x + width - radius, y);        this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);        this.ctx.lineTo(x + width, y + height - radius);        this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);        this.ctx.lineTo(x + radius, y + height);        this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);        this.ctx.lineTo(x, y + radius);        this.ctx.quadraticCurveTo(x, y, x + radius, y);        this.ctx.fillStyle = reactConfig.fillColor || &#x27;rgba(0, 0, 0, 0.5)&#x27;;        this.ctx.strokeStyle = reactConfig.strokeColor || &#x27;rgba(0, 0, 0, 0)&#x27;;        this.ctx.closePath();        this.ctx.fill();        this.ctx.stroke();    &#125;    /**        width: 矩形宽度        height: 文字颜色        bgColor: 背景颜色    */    fillColor(config) &#123;        if (!config?.bgColor) &#123;            return;        &#125;        const width = config.width * this.scale;        const height = config.height * this.scale;        this.ctx.fillStyle = config.bgColor;        this.ctx.fillRect(0, 0, width, height);        this.ctx.restore();    &#125;    toDataURL() &#123;        return this.canvasDom.toDataURL(&#x27;image/png&#x27;, 1);    &#125;    updateInstance(config) &#123;        this.width = config.width || 375;        this.height = config.height || 616;        this.scale = config.scale || 3;        this.canvasDom.width = this.width * this.scale;        this.canvasDom.height = this.height * this.scale;    &#125;&#125;","slug":"canvas-screenshot","date":"2024-08-29T12:52:43.149Z","categories_index":"canvas","tags_index":"canvas","author_index":"M"},{"id":"53e70211b9fa8a0658b9a8cefd096926","title":"多行文本展开收起的实现方式","content":"多行文本超过指定行数，进行文本截断并显示省略号，并通过展开和收起来控制是否显示全部内容，调研很多种方式，目前这个是最合适的且最终的实现方案。\n具体代码\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div      class=&quot;text-wrapper&quot;      ref=&quot;wrapper&quot;      :class=&quot;&#123; &#x27;text-wrapper-height&#x27;: isExpand &#125;&quot;    &gt;      &lt;div class=&quot;text-wrapper-inner&quot;&gt;        &lt;div          class=&quot;text-wrapper-fulltext&quot;          @click=&quot;onActionClick&quot;          v-if=&quot;showFillText&quot;        &gt;          &#123;&#123; !isExpand ? &quot;...全文&quot; : &quot;收起&quot; &#125;&#125;        &lt;/div&gt;        &lt;div class=&quot;text-wrapper-text&quot; ref=&quot;text&quot;&gt;          这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      showFillText: false,      isExpand: false    &#125;;  &#125;,  mounted() &#123;    this.titleHeight();  &#125;,  methods: &#123;    titleHeight() &#123;      const &#123; text, wrapper &#125; = this.$refs;      const wrapperScrollHeight = wrapper?.scrollHeight || 0;      const wrapperHeight = wrapper?.offsetHeight || 0;      const contentHeight = text?.offsetHeight || 0;      if (        wrapperScrollHeight &gt; wrapperHeight + 10 ||        contentHeight &gt; wrapperHeight      ) &#123;        this.showFillText = true;      &#125;    &#125;,    onActionClick() &#123;      this.isExpand = !this.isExpand;    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style&gt;body &#123;  height: 100vh;  display: flex;  flex-direction: column;  align-items: center;  justify-content: center;&#125;#app &#123;  width: 390px;  height: auto;&#125;.text-wrapper &#123;  display: flex;  max-height: 72px;  overflow: hidden;  position: relative;  word-break: break-all;  transition: max-height 0.2s linear;&#125;.text-wrapper.text-wrapper-height &#123;  max-height: 400px;&#125;.text-wrapper-inner &#123;  width: 100%;  position: relative;&#125;.text-wrapper-inner::before &#123;  content: &quot;&quot;;  float: right;  clear: both;  width: 0;  height: calc(100% - 23px);&#125;.text-wrapper-fulltext &#123;  padding-right: 4px;  font-size: 16px;  line-height: 19px;  letter-spacing: 0.3px;  text-align: center;  float: right;  clear: both;  color: #576b95;  cursor: pointer;&#125;.text-wrapper-text &#123;  font-size: 16px;  line-height: 23px;&#125;&lt;/style&gt;\n\nfull-text codepen\n","slug":"full-text","date":"2024-08-29T12:52:38.496Z","categories_index":"html&css","tags_index":"html&css","author_index":"M"},{"id":"62bc8025e0eb197d420ffa98bc79c161","title":"git 常用命令","content":"目前常用的git命令整理\n1，git init\n初始化一个新的Git仓库。\n这将在当前目录中创建一个名为”.git”的子目录，Git会将所有仓库的元数据存储在其中。\n2，git clone\n克隆一个已存在的仓库。\n这会创建一个本地仓库的副本，包括其所有的历史记录和分支。\ngit clone &lt;仓库链接&gt;\n3，git add\n将修改内容添加到下一次提交中。\n这将把指定的文件添加到暂存区，这些文件将包含在下一次提交中。\ngit add file1.txt file2.txt\n4，git commit\n创建一个新的提交。\n这将记录暂存区的修改以及自上次提交以来所做的任何其他修改，并附带一条描述这些修改的提交信息。\ngit commit -m “添加新功能”\ngit commit ‘’ --noverify 取消提交时格式化代码\n5，git push\n将提交推送到远程仓库。\n这将把本地的提交发送到指定的远程仓库，更新远程分支以包含新的提交。\ngit push origin main\n6，git pull\n从远程仓库获取并合并修改。\n这会从指定的远程仓库中获取最新的提交，并将其合并到当前分支中。\ngit pull origin main\n8，git branch\n列出、创建或删除分支。\n这个命令可以用来列出仓库中可用的分支，创建新的分支或删除现有的分支。\ngit branch new-branch\n9，git checkout\n切换到不同的分支。\n这个命令允许你切换到仓库中的不同分支，并将其作为当前工作分支。\ngit checkout main\n10，git merge\n将一个分支合并到另一个分支。\n这个命令将一个分支的修改合并到另一个分支中，创建一个反映合并变化的新提交。\ngit merge new-branch\n11，git status\n显示仓库的状态。\n这个命令会显示当前分支、任何暂存或未暂存的修改以及任何未跟踪的文件。\ngit status\n12，git rebase\n将一个分支的修改合并到另一个分支。\n假设你在”XYZ”分支上进行了一些修改，你希望将这些修改合并到”main”分支中。你可以使用git rebase命令将你的修改重新应用到main分支之上。\n13，git stash\n临时保存还未准备提交的修改。\n如果你的修改还没有准备好提交，但你想要切换到另一个分支继续工作，你可以临时保存你的修改以便以后使用，并在不丢失进度的情况下切换分支。\n（1）git stash save “save message”  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。\n（2）git stash list  ：查看stash了哪些存储\n（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}\n（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@{$num}  -p ，比如第二个：git stash show  stash@{1}  -p\n（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} \n（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}\n（7）git stash drop stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储\n（8）git stash clear ：删除所有缓存的stash\n14，git revert\n假设你在之前的提交中犯了一个错误，需要撤销它。你可以使用git revert创建一个新的提交，该提交会撤销之前提交引入的修改。\ngit revert ..\n15，删除分支\n删除本地分支\ngit branch -D branch\ngit push --delete origin branch\n16, git reset\n回退提交错误的代码\ngit reset --hard log\ngit push -f origin branch\n","slug":"git","date":"2024-08-17T07:36:39.589Z","categories_index":"git","tags_index":"git","author_index":"M"},{"id":"13f6ca6756a4b641116bd6f0d8205d5e","title":"Intersection Observer 交叉观察","content":"IntersectionObserver API 是现代浏览器提供的一种异步观察目标元素与祖先元素（或顶级文档视窗）交叉状态的方法。它可以用于实现懒加载图片、无限滚动、以及其他需要监听元素可见性的功能。\n基本概念在开始使用 IntersectionObserver 之前，我们需要了解几个基本概念：\n目标元素（Target Element）：你想要观察的元素。根元素（Root Element）：用来检测目标元素的可见性变化的容器元素，默认为浏览器视窗。阈值（Threshold）：触发回调函数的目标元素可见比例。\n为什么使用 IntersectionObserver传统上，我们会使用 scroll 事件监听元素的可见性变化。然而，这种方法有几个缺点：\n性能问题：滚动事件会频繁触发，从而导致性能问题。复杂的计算：需要手动计算元素的可见性。IntersectionObserver 可以解决这些问题：性能更好：IntersectionObserver 是异步的，不会频繁触发。简单易用：只需要定义一次观察逻辑，浏览器会处理所有计算。\n创建 IntersectionObserver 实例IntersectionObserver 是一个构造函数，我们需要先创建一个实例。构造函数接收两个参数：回调函数和可选配置对象。\nconst options = &#123;  root: null, // 默认为视窗  rootMargin: &#x27;0px&#x27;, // 视窗的外边距  threshold: 0.1 // 目标元素可见比例达到 10% 时触发回调&#125;;const ob = new IntersectionObserver(listener, options);\n\n定义回调函数回调函数在目标元素的可见性变化时被调用。它接收两个参数：entries 和 observer。\nconst listener = (entries, observer) =&gt; &#123;  entries.forEach(entry =&gt; &#123;    if (entry.isIntersecting) &#123;      console.log(&#x27;目标元素进入视窗&#x27;);      // 在此处理进入视窗后的逻辑    &#125; else &#123;      console.log(&#x27;目标元素离开视窗&#x27;);      // 在此处理离开视窗后的逻辑    &#125;  &#125;);&#125;;\n\n观察目标元素创建 IntersectionObserver 实例后，使用 observe 方法开始观察目标元素。\nconst imgs = document.querySelectorAll(&quot;img[data-src]&quot;);imgs.forEach((img)=&gt; &#123;  ob.observe(img)&#125;)\n\n停止观察如果不再需要观察某个元素，可以使用 unobserve 方法。\nobserver.unobserve(target);\n\n当不再需要 IntersectionObserver 实例时，可以调用 disconnect 方法停止观察所有目标元素。\nobserver.disconnect();\n\n完整例子：\n图片懒加载codepen\n","slug":"intersection-observer","date":"2024-08-17T06:36:30.142Z","categories_index":"javascript","tags_index":"javascript","author_index":"M"},{"id":"92e648db1789cade1fa84cef6b1bbfe8","title":"逐帧动画实现无限轮播","content":"最近有一个无限滚动轮播的需求，最开始用js+延时器写了一版，但因为是用在首页性能消耗很大，所以想试试能不能用css搞定，嘿，还真发现了一种方法，虽然最后没有使用这种方法，但也学学看吧。\n先看个完成效果\n\n\n我们来简单分析分析，从表面上看，确实好像只有元素的 transform: translate() 在位移，但是注意，这里有两个难点：\n\n这是个无限轮播的效果，我们的动画需要支持任意多个元素的无限轮播切换\n因为是轮播，所以，运行到最后一个的时候，需要动画切到第一个元素\n\n\n\n到这里，你可以暂停思考一下，如果有 20 个元素，需要进行类似的无限轮播播报，使用 CSS 实现，你会怎么去做呢？\n逐帧动画控制整体切换在这里，要实现轮播效果，并且是任意个数，我们可以借助 animation-timing-function: steps()\n:root &#123;  // 轮播的个数  --s: 6;  // 单个 li 容器的高度  --h: 36;  // 单次动画的时长  --speed: 1.5s;&#125;.g-container &#123;  width: 300px;  height: calc(var(--h) * 1px);&#125;ul &#123;  display: flex;  flex-direction: column;  animation: move calc(var(--speed) * var(--s)) steps(var(--s)) infinite;&#125;ul li &#123;  width: 100%;&#125;@keyframes move &#123;  0% &#123;    transform: translate(0, 0);  &#125;  100% &#123;    transform: translate(0, calc(var(--s) * var(--h) * -1px));  &#125;&#125;\n\n别看到上述有几个 CSS 变量就慌了，其实很好理解：\ncalc(var(--speed) * var(--s))：单次动画的耗时 * 轮播的个数，也就是总动画时长\nsteps(var(--s)) 就是逐帧动画的帧数，这里也就是 steps(6)，很好理解\ncalc(var(--s) * var(--h) * -1px)) 单个 li 容器的高度 * 轮播的个数，其实就是 ul 的总体高度，用于设置逐帧动画的终点值\n效果如下：\n\n这样，我们就得到了整体的结构，至少，整个效果是循环的。\n但是由于只是逐帧动画，所以只能看到切换，但是每一帧之间，没有过渡动画效果。所以，接下来，我们还得引入补间动画。\n利用补间动画实现两组数据间的切换我们需要利用补间动画，实现动态的切换效果。\n这一步，其实也非常简单，我们要做的，就是将一组数据，利用 transform，从状态 A 位移到 状态 B。\n把一开始提到的 逐帧动画 和这里这个 补间动画 结合一下，ul 的整体移动，和 li 的 单个移动叠在在一起：\n&lt;div class=&quot;g-container&quot;&gt;  &lt;ul style=&quot;--s: 6&quot;&gt;    &lt;li&gt;1111111&lt;/li&gt;    &lt;li&gt;2222222&lt;/li&gt;    &lt;li&gt;3333333&lt;/li&gt;    &lt;li&gt;4444444&lt;/li&gt;    &lt;li&gt;5555555&lt;/li&gt;    &lt;li&gt;6666666&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;\n\n:root &#123;  // 轮播的个数  --s: 6;  // 单个 li 容器的高度  --h: 36;  // 单次动画的时长  --speed: 1.5s;&#125;.g-container &#123;  width: 300px;  height: calc(var(--h) * 1px);&#125;ul &#123;  display: flex;  flex-direction: column;  animation: move calc(var(--speed) * var(--s)) steps(var(--s)) infinite;&#125;ul li &#123;  width: 100%;  animation: liMove calc(var(--speed)) infinite;&#125;@keyframes move &#123;  0% &#123;    transform: translate(0, 0);  &#125;  100% &#123;    transform: translate(0, calc(var(--s) * var(--h) * -1px));  &#125;&#125;@keyframes liMove &#123;  0% &#123;    transform: translate(0, 0);  &#125;  80%,  100%  &#123;    transform: translate(0, calc(var(--h) * -1px));  &#125;&#125;\n\n效果变为这样\n\n基于 逐帧动画 和 补间动画 的结合，我们几乎实现了一个轮播效果\n当然，有一点瑕疵，可以看到，最后一组数据，是从第六组数据 transform 移动向了一组空数据\n实际开发过轮播的同学肯定知道，这里，其实也很好处理，我们只需要在末尾，补一组头部的第一个数据即可\n这样我们就实现了开头那样的无限轮播效果啦~\n横向的也是可以的，只需改变位移方向即可实现\n掌握了这个技巧之后，你可以将它运用在非常多只需要简化版的轮播效果之上。\n完整代码codepen\n\n再简单总结一下，有实用也有缺点：\n\n利用 逐帧动画，实现整体的轮播的循环效果\n利用 补间动画，实现具体的 *状态A 向 状态B 的动画效果\n逐帧动画 配合 补间动画 构成整体轮播的效果\n通过向 HTML 结构末尾补充一组头部数据，实现整体动画的衔接\n通过 HTML 元素的 style 标签，利用 CSS 变量，填入实际的参与循环的 DOM 个数，可以实现 JavaScript 与 CSS 的打通\n注意iOS系统14以下的暂时不能兼容，如果要是兼容的话最好还是不要使用此方法\n跳转页面再回来可能会有错乱\n\n\n\n","slug":"animation-steps","date":"2024-08-11T07:44:20.576Z","categories_index":"css,animation","tags_index":"animation","author_index":"M"},{"id":"02dffd67a1266aabc62643a303624bae","title":"微信头像九宫格布局","content":"近期写页面遇到需要九宫格布局的情况，研究许久现记录一下布局方式。\n我们知道 flex 布局可以设置flex-wrap: wrap在元素放不下后自动换行，那么设置flex-wrap: wrap-reverse;就可以反过来布局，达到三个头像一个在上的效果啦~\n核心代码\n display: flex;flex-wrap: wrap-reverse;\n\n示例\n\n图片九宫格布局效果-codepen\n","slug":"微信头像九宫格布局","date":"2024-08-04T08:19:28.411Z","categories_index":"html&css","tags_index":"html&css","author_index":"M"},{"id":"758086e3bca7c26b0f11ceb6e2c6e587","title":"屏幕适配方案","content":"1.使用 @media搭配 rem 单位rem是相对于根html元素的字体大小的单位\nhtml &#123;  font-size: 16px;&#125;span &#123;  font-size: 1rem; // 1rem = 16px&#125;\n\n借助@media可以为各种不同大小屏幕的根html元素设置不同的的字体大小\n@media only screen and (max-width: 400px) &#123;\thtml &#123;\t\tfont-size: 16px;\t&#125;&#125;@media only screen and (min-width: 400px) and (max-width: 700px) &#123;\thtml &#123;\t\tfont-size: 20px;\t&#125;&#125;@media only screen and (min-width: 700px) &#123;\thtml &#123;\t\tfont-size: 25px;\t&#125;&#125;\n\n使用插件px to rem &amp; rpx &amp; vw (cssrem)，插件设置Root Font Size(默认16)之后，可以自动将px计算成rem，alt+z一键转换\n缺点 需要写多个@media适配尺寸   根标签font-size大小不好把握!!!\n2.flexble适配方案GitHub - amfe-flexible: 可伸缩布局方案\n使用js动态设置rem基准值\n// 核心代码：将屏幕分成多少等分的rem，这里可以根据设计稿自己调整function setRemUnit () &#123;    var rem = docEl.clientWidth / 10    docEl.style.fontSize = rem + &#x27;px&#x27;&#125;\n\n在脚手架中可以配合插件postcss-pxtorem，打包后将px自动转换成rem\n// .postcssrc.js/** * PostCSS 配置文件 */ module.exports = &#123;    // 配置要使用的 PostCSS 插件    plugins: &#123;      // 配置使用 autoprefixer 插件      // 作用：生成浏览器 CSS 样式规则前缀      // VueCLI 内部已经配置了 autoprefixer 插件      // 所以又配置了一次，所以产生冲突了      // &#x27;autoprefixer&#x27;: &#123; // autoprefixer 插件的配置      //   // 配置要兼容到的环境信息      //   browsers: [&#x27;Android &gt;= 4.0&#x27;, &#x27;iOS &gt;= 8&#x27;]      // &#125;,        // 配置使用 postcss-pxtorem 插件      // 作用：把 px 转为 rem      &#x27;postcss-pxtorem&#x27;: &#123;        rootValue (&#123; file &#125;) &#123;           return file.indexOf(&#x27;vant&#x27;) !== -1 ? 37.5 : 75 // 根据条件设置        &#125;, // 表示根元素字体大小，它会根据根元素大小进行单位转换        propList: [&#x27;*&#x27;] // 用来设定可以从 px 转为 rem 的属性      &#125;    &#125;  &#125;\n\n由于viewport单位得到众多浏览器的兼容，lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。\n3.viewport 适配方案设置viewport meta 标记来控制视口大小等于设备宽度，并且不允许手动缩放。\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maxmun-scale=1.0, user-scalable=0&quot; /&gt;\n-    - vw：视口的最大宽度，1vw&#x3D;视口宽度的百分之一；\ntxt- vh：视口得最大高度，1vh=视口高度的百分之一；\n\n- vmin：视口高度 vw 和宽度 vh 两者之间的最小值。\n\n- vmax：视口高度 vw 和宽度 vh 两者之间的最大值。// 假设屏幕宽度为750html &#123;\twidth: 100vw; // 750px&#125;\n\n在脚手架中可以配合插件postcss-px-to-viewport，打包后将px自动转换成vw\n4.scale缩放适配方案多用于大屏数据可视化项目\n取屏幕宽高和设计稿宽高相比中最小的比例对外层盒子进行缩放并居中\n#scaleContainer &#123;    position: absolute;    left: 50%;    top: 50%;&#125;\n\n// 设计稿的宽度let desginWidth = 1920;let desginHeight = 1080;document.getElementById(&#x27;scaleContainer&#x27;).style.width = `$&#123;desginWidth&#125;px`;document.getElementById(&#x27;scaleContainer&#x27;).style.height = `$&#123;desginHeight&#125;px`;function setScale() &#123;    let trueWidth = window.innerWidth;    let trueHeight = window.innerHeight;    let wScale = trueWidth / desginWidth;    let hScale = trueHeight / desginHeight;    let scale = Math.min(wScale, hScale);    document.getElementById(&#x27;scaleContainer&#x27;).style.transform = `scale($&#123;scale&#125;) translate(-50%, -50%)`;&#125;window.addEventListener(&#x27;resize&#x27;, setScale);setScale();\n\nvue项目可以使用v-scale-screen插件\n缺点：当屏幕尺寸比例差距过大会有空白，以及模糊的效果。\n总结：\n移动端推荐使用viewport适配方案\npc端或者响应式推荐@media搭配各种单位\n大屏可视化推荐使用scale缩放\n","slug":"屏幕适配方案","date":"2024-08-04T08:19:02.993Z","categories_index":"html&css","tags_index":"html&css","author_index":"M"},{"id":"1fe4dcdfe1c34a2e89ece05477f6b2fb","title":"滚动驱动动画animation-timeline","content":"CSS滚动驱动动画animation-timeline终于正式支持了，一些炫酷的动画终于可以用简单的写法支持啦，快来看看吧~一、快速入门 CSS 滚动驱动动画下面是一个页面进度指示器，进度随着页面的滚动而变化\n\n首先代码很简单，先是一个容器\n&lt;div&gt;这&lt;/div&gt;&lt;div&gt;里&lt;/div&gt;&lt;div&gt;是&lt;/div&gt;&lt;div&gt;测&lt;/div&gt;&lt;div&gt;试&lt;/div&gt;&lt;div&gt;文&lt;/div&gt;&lt;div&gt;字&lt;/div&gt;\n\n然后是css和动画，并且加上我们今天的核心主角animation-timeline\n这样进度条就乖乖的跟随页面滚动而变化了（注意Chrome 115+）\n动画时长不能为0，因为为0表示动画不执行，所以必须写上一个任意非零时间，或者直接为auto!!!\nbody::after &#123;  content: &quot;&quot;;  position: fixed;  top: 0;  left: 0;  right: 0;  height: 10px;  background-color: red;  transform-origin: 0 50%;  animation: grow-progress 1s linear;  animation-timeline: scroll();&#125;div &#123;  display: flex;  align-items: center;  justify-content: center;  height: 300px;  margin: 10px;  background-color: #6467F0;  color: #FFFFFF;  font-size: 80px;&#125;@keyframes grow-progress &#123;  from &#123;    transform: scaleX(0);  &#125;  to &#123;    transform: scaleX(1);  &#125;&#125;\n是不是非常神奇?\n二、CSS 滚动驱动动画\n大家可能知道，传统 JS 监听滚动有一些问题，如下\n\n现代浏览器在单独的进程上执行滚动，因此只能异步传递滚动事件。\n\n由于是异步传递，因此主线程动画容易出现卡顿\n\n\n\n\n因此，为了解决滚动卡顿的问题，CSS 滚动驱动动画应运而生。那么，什么是 CSS 滚动驱动动画？\n默认情况下，动画是「随着时间的流逝」而播放的。\nCSS 滚动驱动动画指的是将动画的执行过程由页面滚动进行接管，也就是这种情况下，动画只会跟随页面滚动的变化而变化，也就是滚动多少，动画就执行多少，时间不再起作用。\n如何改变动画的时间线呢？那就需要用到这个核心概念了：animation-timeline，表示动画时间线（或者叫时间轴），用于控制 CSS 动画进度的时间线，是必不可少的一个属性。\n默认值是auto，也是就传统的时间线。下面是它一些关键词\n/* 关键词 */animation-timeline: none;animation-timeline: auto;/* 命名时间线 */animation-timeline: --timeline_name;/* 滚动时间线 */animation-timeline: scroll();animation-timeline: scroll(scroller axis);/* 视图时间线 */animation-timeline: view();animation-timeline: view(axis inset);\n\n是不是有点混乱？不要慌，实际滚动场景千千万，这里可以分为两大类：一类是滚动进度时间线，也就是上面的关键词scroll()，还有一类是视图进度时间线，也就是关键词view()。\n三. CSS 滚动进度时间线滚动进度时间线（scroll progress timeline）。表示页面或者容器滚动，将滚动进度映射到动画进度上。\n这里的scroll()是一个简写，可以传递两个参数，分别是和\n\n表示滚动容器，支持以下几个关键值\n\nnearest：使用最近的祖先滚动容器（默认）\n\nroot：使用文档视口作为滚动容器。\n\nself：使用元素本身作为滚动容器。\n\n\n\n\n表示滚动方向，支持以下几个关键值\n\nblock：滚动容器的块级轴方向（默认）。\n\ninline：滚动容器内联轴方向。\n\ny：滚动容器沿 y 轴方向。\n\nx：滚动容器沿 x 轴方向。\n\n\n四、CSS 视图进度时间线视图进度时间线（view progress timeline）。这个名字有些难以理解，其实表示的是一个元素出现在页面视野范围内的进度，也就是关注的是元素自身位置。元素刚刚出现之前代表 0%进度，元素完全离开之后代表 100% 进度\n这个概念非常像JS中的Intersection_Observer_API，也就交叉观察者，可以监测到元素在可视区的情况，因此，在这种场景中，无需关注滚动容器是哪个，只用处理自身就行了。\n由于无需关注滚动容器，所以它的参数也不一样，分别是和\n\n表示滚动方向，支持以下几个关键值\n\nblock：滚动容器的块级轴方向（默认）。\n\ninline：滚动容器内联轴方向。\n\ny：滚动容器沿 y 轴方向。\n\nx：滚动容器沿 x 轴方向。\n\n\n\n\n表示调整元素的视区范围，有点类似scroll-padding，支持两个值，表示开始和结束两个范围。\nanimation-timeline: view(auto); /* 默认值 */animation-timeline: view(20%);animation-timeline: view(200px);animation-timeline: view(20% 40%);animation-timeline: view(20% 200px);animation-timeline: view(100px 200px);animation-timeline: view(auto 200px);\n\n五、CSS 动画范围区间默认情况下，动画会根据滚动区间范围一一映射，就比如第一个滚动指示器的例子，滚动多少，指示器的进度就走多少。\n那么，如何截取一定的滚动区间呢？这就要涉及一个新的属性，叫做animation-range，也就是“动画范围”。\n由于只是滚动容器的监听，因此比较简单，直接设置范围就行了\n.back&#123;  /**/  animation: back-progress 1s linear forwards;  animation-timeline: scroll();  animation-range: 0 100px;&#125;animation-range: normal; /* 等价于 normal normal */animation-range: 20%; /* 等价于 20% normal */animation-range: 100px; /* 等价于 100px normal */@keyframes back-progress &#123;  from &#123; transform: translateY(150%); &#125;  to &#123; transform: translateY(0%); &#125;&#125;\n\n那么，一个返回按钮就像滚动进度条那样，慢慢的出来，直到滚动到最底部才完全出\n上面讲的代码完整列子\n\n目前这个属性兼容性还不是特别好，可以用CSS.supports做兼容处理，以上就是css animation-timeline的全部内容了\ncodepen完整示例\n","slug":"animation-timeline","date":"2024-08-04T08:17:26.873Z","categories_index":"css,animation","tags_index":"css","author_index":"M"}]