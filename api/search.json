[{"id":"02dffd67a1266aabc62643a303624bae","title":"微信头像九宫格布局","content":"近期写页面遇到需要九宫格布局的情况，研究许久现记录一下布局方式。\n我们知道 flex 布局可以设置flex-wrap: wrap在元素放不下后自动换行，那么设置flex-wrap: wrap-reverse;就可以反过来布局，达到三个头像一个在上的效果啦~\n核心代码\n display: flex;flex-wrap: wrap-reverse;\n\n示例\n\n图片九宫格布局效果-codepen\n","slug":"微信头像九宫格布局","date":"2024-08-04T08:19:28.411Z","categories_index":"html&css","tags_index":"html&css","author_index":"M"},{"id":"758086e3bca7c26b0f11ceb6e2c6e587","title":"屏幕适配方案","content":"1.使用 @media搭配 rem 单位rem是相对于根html元素的字体大小的单位\nhtml &#123;  font-size: 16px;&#125;span &#123;  font-size: 1rem; // 1rem = 16px&#125;\n\n借助@media可以为各种不同大小屏幕的根html元素设置不同的的字体大小\n@media only screen and (max-width: 400px) &#123;\thtml &#123;\t\tfont-size: 16px;\t&#125;&#125;@media only screen and (min-width: 400px) and (max-width: 700px) &#123;\thtml &#123;\t\tfont-size: 20px;\t&#125;&#125;@media only screen and (min-width: 700px) &#123;\thtml &#123;\t\tfont-size: 25px;\t&#125;&#125;\n\n使用插件px to rem &amp; rpx &amp; vw (cssrem)，插件设置Root Font Size(默认16)之后，可以自动将px计算成rem，alt+z一键转换\n缺点 需要写多个@media适配尺寸   根标签font-size大小不好把握!!!\n2.flexble适配方案GitHub - amfe-flexible: 可伸缩布局方案\n使用js动态设置rem基准值\n// 核心代码：将屏幕分成多少等分的rem，这里可以根据设计稿自己调整function setRemUnit () &#123;    var rem = docEl.clientWidth / 10    docEl.style.fontSize = rem + &#x27;px&#x27;&#125;\n\n在脚手架中可以配合插件postcss-pxtorem，打包后将px自动转换成rem\n// .postcssrc.js/** * PostCSS 配置文件 */ module.exports = &#123;    // 配置要使用的 PostCSS 插件    plugins: &#123;      // 配置使用 autoprefixer 插件      // 作用：生成浏览器 CSS 样式规则前缀      // VueCLI 内部已经配置了 autoprefixer 插件      // 所以又配置了一次，所以产生冲突了      // &#x27;autoprefixer&#x27;: &#123; // autoprefixer 插件的配置      //   // 配置要兼容到的环境信息      //   browsers: [&#x27;Android &gt;= 4.0&#x27;, &#x27;iOS &gt;= 8&#x27;]      // &#125;,        // 配置使用 postcss-pxtorem 插件      // 作用：把 px 转为 rem      &#x27;postcss-pxtorem&#x27;: &#123;        rootValue (&#123; file &#125;) &#123;           return file.indexOf(&#x27;vant&#x27;) !== -1 ? 37.5 : 75 // 根据条件设置        &#125;, // 表示根元素字体大小，它会根据根元素大小进行单位转换        propList: [&#x27;*&#x27;] // 用来设定可以从 px 转为 rem 的属性      &#125;    &#125;  &#125;\n\n由于viewport单位得到众多浏览器的兼容，lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。\n3.viewport 适配方案设置viewport meta 标记来控制视口大小等于设备宽度，并且不允许手动缩放。\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maxmun-scale=1.0, user-scalable=0&quot; /&gt;\n-    - vw：视口的最大宽度，1vw&#x3D;视口宽度的百分之一；\ntxt- vh：视口得最大高度，1vh=视口高度的百分之一；\n\n- vmin：视口高度 vw 和宽度 vh 两者之间的最小值。\n\n- vmax：视口高度 vw 和宽度 vh 两者之间的最大值。// 假设屏幕宽度为750html &#123;\twidth: 100vw; // 750px&#125;\n\n在脚手架中可以配合插件postcss-px-to-viewport，打包后将px自动转换成vw\n4.scale缩放适配方案多用于大屏数据可视化项目\n取屏幕宽高和设计稿宽高相比中最小的比例对外层盒子进行缩放并居中\n#scaleContainer &#123;    position: absolute;    left: 50%;    top: 50%;&#125;\n\n// 设计稿的宽度let desginWidth = 1920;let desginHeight = 1080;document.getElementById(&#x27;scaleContainer&#x27;).style.width = `$&#123;desginWidth&#125;px`;document.getElementById(&#x27;scaleContainer&#x27;).style.height = `$&#123;desginHeight&#125;px`;function setScale() &#123;    let trueWidth = window.innerWidth;    let trueHeight = window.innerHeight;    let wScale = trueWidth / desginWidth;    let hScale = trueHeight / desginHeight;    let scale = Math.min(wScale, hScale);    document.getElementById(&#x27;scaleContainer&#x27;).style.transform = `scale($&#123;scale&#125;) translate(-50%, -50%)`;&#125;window.addEventListener(&#x27;resize&#x27;, setScale);setScale();\n\nvue项目可以使用v-scale-screen插件\n缺点：当屏幕尺寸比例差距过大会有空白，以及模糊的效果。\n总结：\n移动端推荐使用viewport适配方案\npc端或者响应式推荐@media搭配各种单位\n大屏可视化推荐使用scale缩放\n","slug":"屏幕适配方案","date":"2024-08-04T08:19:02.993Z","categories_index":"html&css","tags_index":"html&css","author_index":"M"},{"id":"1fe4dcdfe1c34a2e89ece05477f6b2fb","title":"滚动驱动动画animation-timeline","content":"CSS滚动驱动动画animation-timeline终于正式支持了，一些炫酷的动画终于可以用简单的写法支持啦，快来看看吧~一、快速入门 CSS 滚动驱动动画下面是一个页面进度指示器，进度随着页面的滚动而变化\n\n首先代码很简单，先是一个容器\n&lt;div&gt;这&lt;/div&gt;&lt;div&gt;里&lt;/div&gt;&lt;div&gt;是&lt;/div&gt;&lt;div&gt;测&lt;/div&gt;&lt;div&gt;试&lt;/div&gt;&lt;div&gt;文&lt;/div&gt;&lt;div&gt;字&lt;/div&gt;\n\n然后是css和动画，并且加上我们今天的核心主角animation-timeline\n这样进度条就乖乖的跟随页面滚动而变化了（注意Chrome 115+）\n动画时长不能为0，因为为0表示动画不执行，所以必须写上一个任意非零时间，或者直接为auto!!!\nbody::after &#123;  content: &quot;&quot;;  position: fixed;  top: 0;  left: 0;  right: 0;  height: 10px;  background-color: red;  transform-origin: 0 50%;  animation: grow-progress 1s linear;  animation-timeline: scroll();&#125;div &#123;  display: flex;  align-items: center;  justify-content: center;  height: 300px;  margin: 10px;  background-color: #6467F0;  color: #FFFFFF;  font-size: 80px;&#125;@keyframes grow-progress &#123;  from &#123;    transform: scaleX(0);  &#125;  to &#123;    transform: scaleX(1);  &#125;&#125;\n是不是非常神奇?\n二、CSS 滚动驱动动画\n大家可能知道，传统 JS 监听滚动有一些问题，如下\n\n现代浏览器在单独的进程上执行滚动，因此只能异步传递滚动事件。\n\n由于是异步传递，因此主线程动画容易出现卡顿\n\n\n\n\n因此，为了解决滚动卡顿的问题，CSS 滚动驱动动画应运而生。那么，什么是 CSS 滚动驱动动画？\n默认情况下，动画是「随着时间的流逝」而播放的。\nCSS 滚动驱动动画指的是将动画的执行过程由页面滚动进行接管，也就是这种情况下，动画只会跟随页面滚动的变化而变化，也就是滚动多少，动画就执行多少，时间不再起作用。\n如何改变动画的时间线呢？那就需要用到这个核心概念了：animation-timeline，表示动画时间线（或者叫时间轴），用于控制 CSS 动画进度的时间线，是必不可少的一个属性。\n默认值是auto，也是就传统的时间线。下面是它一些关键词\n/* 关键词 */animation-timeline: none;animation-timeline: auto;/* 命名时间线 */animation-timeline: --timeline_name;/* 滚动时间线 */animation-timeline: scroll();animation-timeline: scroll(scroller axis);/* 视图时间线 */animation-timeline: view();animation-timeline: view(axis inset);\n\n是不是有点混乱？不要慌，实际滚动场景千千万，这里可以分为两大类：一类是滚动进度时间线，也就是上面的关键词scroll()，还有一类是视图进度时间线，也就是关键词view()。\n三. CSS 滚动进度时间线滚动进度时间线（scroll progress timeline）。表示页面或者容器滚动，将滚动进度映射到动画进度上。\n这里的scroll()是一个简写，可以传递两个参数，分别是和\n\n表示滚动容器，支持以下几个关键值\n\nnearest：使用最近的祖先滚动容器（默认）\n\nroot：使用文档视口作为滚动容器。\n\nself：使用元素本身作为滚动容器。\n\n\n\n\n表示滚动方向，支持以下几个关键值\n\nblock：滚动容器的块级轴方向（默认）。\n\ninline：滚动容器内联轴方向。\n\ny：滚动容器沿 y 轴方向。\n\nx：滚动容器沿 x 轴方向。\n\n\n四、CSS 视图进度时间线视图进度时间线（view progress timeline）。这个名字有些难以理解，其实表示的是一个元素出现在页面视野范围内的进度，也就是关注的是元素自身位置。元素刚刚出现之前代表 0%进度，元素完全离开之后代表 100% 进度\n这个概念非常像JS中的Intersection_Observer_API，也就交叉观察者，可以监测到元素在可视区的情况，因此，在这种场景中，无需关注滚动容器是哪个，只用处理自身就行了。\n由于无需关注滚动容器，所以它的参数也不一样，分别是和\n\n表示滚动方向，支持以下几个关键值\n\nblock：滚动容器的块级轴方向（默认）。\n\ninline：滚动容器内联轴方向。\n\ny：滚动容器沿 y 轴方向。\n\nx：滚动容器沿 x 轴方向。\n\n\n\n\n表示调整元素的视区范围，有点类似scroll-padding，支持两个值，表示开始和结束两个范围。\nanimation-timeline: view(auto); /* 默认值 */animation-timeline: view(20%);animation-timeline: view(200px);animation-timeline: view(20% 40%);animation-timeline: view(20% 200px);animation-timeline: view(100px 200px);animation-timeline: view(auto 200px);\n\n五、CSS 动画范围区间默认情况下，动画会根据滚动区间范围一一映射，就比如第一个滚动指示器的例子，滚动多少，指示器的进度就走多少。\n那么，如何截取一定的滚动区间呢？这就要涉及一个新的属性，叫做animation-range，也就是“动画范围”。\n由于只是滚动容器的监听，因此比较简单，直接设置范围就行了\n.back&#123;  /**/  animation: back-progress 1s linear forwards;  animation-timeline: scroll();  animation-range: 0 100px;&#125;animation-range: normal; /* 等价于 normal normal */animation-range: 20%; /* 等价于 20% normal */animation-range: 100px; /* 等价于 100px normal */@keyframes back-progress &#123;  from &#123; transform: translateY(150%); &#125;  to &#123; transform: translateY(0%); &#125;&#125;\n\n那么，一个返回按钮就像滚动进度条那样，慢慢的出来，直到滚动到最底部才完全出\n上面讲的代码完整列子\n\n目前这个属性兼容性还不是特别好，可以用CSS.supports做兼容处理，以上就是css animation-timeline的全部内容了\ncodepen完整示例\n","slug":"animation-timeline","date":"2024-08-04T08:17:26.873Z","categories_index":"css,animation","tags_index":"css","author_index":"M"}]