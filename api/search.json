[{"id":"1fe4dcdfe1c34a2e89ece05477f6b2fb","title":"滚动驱动动画animation-timeline","content":"CSS滚动驱动动画animation-timeline终于正式支持了，一些炫酷的动画终于可以用简单的写法支持啦~一、快速入门 CSS 滚动驱动动画下面是一个页面进度指示器，进度随着页面的滚动而变化\n\n首先代码很简单，先是一个容器\n&lt;div&gt;这&lt;/div&gt;&lt;div&gt;里&lt;/div&gt;&lt;div&gt;是&lt;/div&gt;&lt;div&gt;测&lt;/div&gt;&lt;div&gt;试&lt;/div&gt;&lt;div&gt;文&lt;/div&gt;&lt;div&gt;字&lt;/div&gt;\n\n然后是css和动画，并且加上我们今天的核心主角animation-timeline\n这样进度条就乖乖的跟随页面滚动而变化了（注意Chrome 115+）\n动画时长不能为0，因为为0表示动画不执行，所以必须写上一个任意非零时间，或者直接为auto!!!\nbody::after &#123;  content: &quot;&quot;;  position: fixed;  top: 0;  left: 0;  right: 0;  height: 10px;  background-color: red;  transform-origin: 0 50%;  animation: grow-progress 1s linear;  animation-timeline: scroll();&#125;div &#123;  display: flex;  align-items: center;  justify-content: center;  height: 300px;  margin: 10px;  background-color: #6467F0;  color: #FFFFFF;  font-size: 80px;&#125;@keyframes grow-progress &#123;  from &#123;    transform: scaleX(0);  &#125;  to &#123;    transform: scaleX(1);  &#125;&#125;\n是不是非常神奇?\n二、CSS 滚动驱动动画\n大家可能知道，传统 JS 监听滚动有一些问题，如下\n\n现代浏览器在单独的进程上执行滚动，因此只能异步传递滚动事件。\n\n由于是异步传递，因此主线程动画容易出现卡顿\n\n\n\n\n因此，为了解决滚动卡顿的问题，CSS 滚动驱动动画应运而生。那么，什么是 CSS 滚动驱动动画？\n默认情况下，动画是「随着时间的流逝」而播放的。\nCSS 滚动驱动动画指的是将动画的执行过程由页面滚动进行接管，也就是这种情况下，动画只会跟随页面滚动的变化而变化，也就是滚动多少，动画就执行多少，时间不再起作用。\n如何改变动画的时间线呢？那就需要用到这个核心概念了：animation-timeline，表示动画时间线（或者叫时间轴），用于控制 CSS 动画进度的时间线，是必不可少的一个属性。\n默认值是auto，也是就传统的时间线。下面是它一些关键词\n/* 关键词 */animation-timeline: none;animation-timeline: auto;/* 命名时间线 */animation-timeline: --timeline_name;/* 滚动时间线 */animation-timeline: scroll();animation-timeline: scroll(scroller axis);/* 视图时间线 */animation-timeline: view();animation-timeline: view(axis inset);\n\n是不是有点混乱？不要慌，实际滚动场景千千万，这里可以分为两大类：一类是滚动进度时间线，也就是上面的关键词scroll()，还有一类是视图进度时间线，也就是关键词view()。\n三. CSS 滚动进度时间线滚动进度时间线（scroll progress timeline）。表示页面或者容器滚动，将滚动进度映射到动画进度上。\n这里的scroll()是一个简写，可以传递两个参数，分别是和\n\n表示滚动容器，支持以下几个关键值\n\nnearest：使用最近的祖先滚动容器（默认）\n\nroot：使用文档视口作为滚动容器。\n\nself：使用元素本身作为滚动容器。\n\n\n\n\n表示滚动方向，支持以下几个关键值\n\nblock：滚动容器的块级轴方向（默认）。\n\ninline：滚动容器内联轴方向。\n\ny：滚动容器沿 y 轴方向。\n\nx：滚动容器沿 x 轴方向。\n\n\n四、CSS 视图进度时间线视图进度时间线（view progress timeline）。这个名字有些难以理解，其实表示的是一个元素出现在页面视野范围内的进度，也就是关注的是元素自身位置。元素刚刚出现之前代表 0%进度，元素完全离开之后代表 100% 进度\n这个概念非常像JS中的Intersection_Observer_API，也就交叉观察者，可以监测到元素在可视区的情况，因此，在这种场景中，无需关注滚动容器是哪个，只用处理自身就行了。\n由于无需关注滚动容器，所以它的参数也不一样，分别是和\n\n表示滚动方向，支持以下几个关键值\n\nblock：滚动容器的块级轴方向（默认）。\n\ninline：滚动容器内联轴方向。\n\ny：滚动容器沿 y 轴方向。\n\nx：滚动容器沿 x 轴方向。\n\n\n\n\n表示调整元素的视区范围，有点类似scroll-padding，支持两个值，表示开始和结束两个范围。\nanimation-timeline: view(auto); /* 默认值 */animation-timeline: view(20%);animation-timeline: view(200px);animation-timeline: view(20% 40%);animation-timeline: view(20% 200px);animation-timeline: view(100px 200px);animation-timeline: view(auto 200px);\n\n五、CSS 动画范围区间默认情况下，动画会根据滚动区间范围一一映射，就比如第一个滚动指示器的例子，滚动多少，指示器的进度就走多少。\n那么，如何截取一定的滚动区间呢？这就要涉及一个新的属性，叫做animation-range，也就是“动画范围”。\n由于只是滚动容器的监听，因此比较简单，直接设置范围就行了\n.back&#123;  /**/  animation: back-progress 1s linear forwards;  animation-timeline: scroll();  animation-range: 0 100px;&#125;animation-range: normal; /* 等价于 normal normal */animation-range: 20%; /* 等价于 20% normal */animation-range: 100px; /* 等价于 100px normal */@keyframes back-progress &#123;  from &#123; transform: translateY(150%); &#125;  to &#123; transform: translateY(0%); &#125;&#125;\n\n那么，一个返回按钮就像滚动进度条那样，慢慢的出来，直到滚动到最底部才完全出\n上面讲的代码完整列子\n\n目前这个属性兼容性还不是特别好，可以用CSS.supports做兼容处理，以上就是css animation-timeline的全部内容了\ncodepen完整示例\n","slug":"animation-timeline","date":"2024-08-04T06:21:59.000Z","categories_index":"css,animation","tags_index":"css","author_index":"M"},{"id":"188442f1e3ef788a161e45fb6af1fd78","title":"记一次根据滚动方向的执行的动画","content":"记录整理最近写的需求，根据滚动条判断手势滑动方向，下滑正常样式，向上滚动展示组件，这里我用一个导航栏代替\n主要代码\n.wrapper__nav.wrapper__nav-sticky &#123;  position: sticky;  top: 0;  z-index: 10;  opacity: 0;  transition: none;&#125;.wrapper__nav.wrapper__nav-down &#123;  opacity: 0;  transform: translateY(-100%);  transition: transform 250ms ease-in-out, opacity 250ms ease-in-out;&#125;.wrapper__nav.wrapper__nav-up &#123;  opacity: 1;  transform: translateY(0);  transition: transform 300ms ease-in-out, opacity 300ms ease-in-out;&#125;\n\n&lt;div  class=&quot;wrapper__nav&quot;  :class=&quot;&#123;&#x27;wrapper__nav-up&#x27;: feedScrollUp,&#x27;wrapper__nav-down&#x27;: feedScrollDown,        &#x27;wrapper__nav-sticky&#x27;: feedOneScreen&#125;&quot;&gt;  &lt;div class=&quot;wrapper__nav-inner&quot;&gt;    &lt;div class=&quot;wrapper__nav-item&quot; v-for=&quot;index in 3&quot; :key=&quot;index&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;\n\nhandleScroll() &#123;    this.scrollTop = window.scrollY;    if (this.scrollTop &lt; 300) &#123;    this.feedOneScreen = false;    this.feedScrollUp = false;    this.feedScrollDown = false;    return;    &#125;if (!this.scrollThrottle) &#123;    this.scrollThrottle = true;    this.lastScrollTop = this.scrollTop;    setTimeout(() =&gt; &#123;        this.scrollThrottle = false;        if (!this.isOpening) &#123;        if (            this.scrollTop &gt; this.lastScrollTop + 10 &amp;&amp;            this.scrollTop &gt; 300        ) &#123;            this.isOpening = true;            this.closeSticky();            setTimeout(() =&gt; &#123;            this.isOpening = false;            &#125;, 250);        &#125; else if (this.scrollTop &lt; this.lastScrollTop - 10) &#123;            this.openSticky();        &#125;        &#125;    &#125;, 100);    &#125;&#125;,openSticky() &#123;    this.feedOneScreen = true;    this.feedScrollUp = true;    this.feedScrollDown = false;&#125;,closeSticky() &#123;    this.feedScrollUp = false;    this.feedScrollDown = true;&#125;\n\nscroll-animation–codepen\n","slug":"scroll-animation","date":"2024-07-20T07:08:38.000Z","categories_index":"vue","tags_index":"animation","author_index":"M"},{"id":"287576a8923ab95c95feb27c51624507","title":"color_utils","content":"关于一些颜色转换的封装\nrgb –&gt; to hslrgb –&gt; to Hexhex –&gt; to RGBhex –&gt; to hslhsl –&gt; to Hexhsl –&gt; to RGB\nconst rgbToHsl = (rgb) =&gt; &#123;    const r = rgb[0] / 255;    const g = rgb[1] / 255;    const b = rgb[2] / 255;      const max = Math.max(r, g, b);    const min = Math.min(r, g, b);      let h; let s; const v = max;    const d = max - min;      s = max === 0 ? 0 : d / max;      if (max === min) &#123;      h = 0;    &#125; else &#123;      switch (max) &#123;        case r:          h = (g - b) / d + (g &lt; b ? 6 : 0);            break;        case g:          h = (b - r) / d + 2;            break;        case b:          h = (r - g) / d + 4;            break;      &#125;      h /= 6;    &#125;      const l = (2 - s) * v / 2;    if (l != 0) &#123;      if (l == 1) &#123;        s = 0;      &#125; else if (l &lt; 0.5) &#123;        s = s * v / (l * 2);      &#125; else &#123;        s = s * v / (2 - l * 2);      &#125;    &#125;      return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];&#125;;const rgbToHex = (rgb) =&gt; &#123;    let r = Math.round(rgb[0]).toString(16);    let g = Math.round(rgb[1]).toString(16);    let b = Math.round(rgb[2]).toString(16);      r = r.length === 1 ? `0$&#123;r&#125;` : r;    g = g.length === 1 ? `0$&#123;g&#125;` : g;    b = b.length === 1 ? `0$&#123;b&#125;` : b;      return `#$&#123;r&#125;$&#123;g&#125;$&#123;b&#125;`;&#125;;const hexToRGB = (hex) =&gt;&#123;    var hexx = hex.replace(&#x27;#&#x27;, &#x27;0x&#x27;);    var r = hexx &gt;&gt; 16;    var g = hexx &gt;&gt; 8 &amp; 0xff;    var b = hexx &amp; 0xff;    return [r, g, b];&#125;;const hexToHsl = (hex) =&gt; &#123;    const rgb = hexToRGB(hex);    const hsl = rgbToHsl(rgb);    return hsl;&#125;;const hslToHex = (hsl) =&gt; &#123;    const rgb = hslToRGB([hsl[0] / 360, hsl[1] / 100, hsl[2] / 100]);    return rgbToHex(rgb);&#125;;const hslToRGB = (hsl) =&gt; &#123;    const h = hsl[0];    const s = hsl[1];    const l = hsl[2];      var r, g, b;      if (s == 0) &#123;      r = g = b = l;    &#125; else &#123;      function hue2rgb(p, q, t) &#123;        if (t &lt; 0) t += 1;        if (t &gt; 1) t -= 1;        if (t &lt; 1/6) return p + (q - p) * 6 * t;        if (t &lt; 1/2) return q;        if (t &lt; 2/3) return p + (q - p) * (2/3 - t) * 6;        return p;      &#125;        var q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;      var p = 2 * l - q;        r = hue2rgb(p, q, h + 1/3);      g = hue2rgb(p, q, h);      b = hue2rgb(p, q, h - 1/3);    &#125;      return [ r * 255, g * 255, b * 255 ];&#125;;","slug":"color_utils","date":"2024-06-15T05:11:58.000Z","categories_index":"","tags_index":"utils","author_index":"M"},{"id":"53e70211b9fa8a0658b9a8cefd096926","title":"多行文本展开收起的实现方式","content":"多行文本超过指定行数，进行文本截断并显示省略号，并通过展开和收起来控制是否显示全部内容，调研很多种方式，目前这个是最合适的且最终的实现方案。\n具体代码\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div      class=&quot;text-wrapper&quot;      ref=&quot;wrapper&quot;      :class=&quot;&#123; &#x27;text-wrapper-height&#x27;: isExpand &#125;&quot;    &gt;      &lt;div class=&quot;text-wrapper-inner&quot;&gt;        &lt;div          class=&quot;text-wrapper-fulltext&quot;          @click=&quot;onActionClick&quot;          v-if=&quot;showFillText&quot;        &gt;          &#123;&#123; !isExpand ? &quot;...全文&quot; : &quot;收起&quot; &#125;&#125;        &lt;/div&gt;        &lt;div class=&quot;text-wrapper-text&quot; ref=&quot;text&quot;&gt;          这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字这是测试字        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      showFillText: false,      isExpand: false    &#125;;  &#125;,  mounted() &#123;    this.titleHeight();  &#125;,  methods: &#123;    titleHeight() &#123;      const &#123; text, wrapper &#125; = this.$refs;      const wrapperScrollHeight = wrapper?.scrollHeight || 0;      const wrapperHeight = wrapper?.offsetHeight || 0;      const contentHeight = text?.offsetHeight || 0;      if (        wrapperScrollHeight &gt; wrapperHeight + 10 ||        contentHeight &gt; wrapperHeight      ) &#123;        this.showFillText = true;      &#125;    &#125;,    onActionClick() &#123;      this.isExpand = !this.isExpand;    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style&gt;body &#123;  height: 100vh;  display: flex;  flex-direction: column;  align-items: center;  justify-content: center;&#125;#app &#123;  width: 390px;  height: auto;&#125;.text-wrapper &#123;  display: flex;  max-height: 72px;  overflow: hidden;  position: relative;  word-break: break-all;  transition: max-height 0.2s linear;&#125;.text-wrapper.text-wrapper-height &#123;  max-height: 400px;&#125;.text-wrapper-inner &#123;  width: 100%;  position: relative;&#125;.text-wrapper-inner::before &#123;  content: &quot;&quot;;  float: right;  clear: both;  width: 0;  height: calc(100% - 23px);&#125;.text-wrapper-fulltext &#123;  padding-right: 4px;  font-size: 16px;  line-height: 19px;  letter-spacing: 0.3px;  text-align: center;  float: right;  clear: both;  color: #576b95;  cursor: pointer;&#125;.text-wrapper-text &#123;  font-size: 16px;  line-height: 23px;&#125;&lt;/style&gt;\n\nfull-text codepen\n","slug":"full-text","date":"2024-05-25T09:10:39.000Z","categories_index":"html&css","tags_index":"html&css","author_index":"M"},{"id":"758086e3bca7c26b0f11ceb6e2c6e587","title":"屏幕适配方案","content":"1.使用 @media搭配 rem 单位rem是相对于根html元素的字体大小的单位\nhtml &#123;  font-size: 16px;&#125;span &#123;  font-size: 1rem; // 1rem = 16px&#125;\n\n借助@media可以为各种不同大小屏幕的根html元素设置不同的的字体大小\n@media only screen and (max-width: 400px) &#123;\thtml &#123;\t\tfont-size: 16px;\t&#125;&#125;@media only screen and (min-width: 400px) and (max-width: 700px) &#123;\thtml &#123;\t\tfont-size: 20px;\t&#125;&#125;@media only screen and (min-width: 700px) &#123;\thtml &#123;\t\tfont-size: 25px;\t&#125;&#125;\n\n使用插件px to rem &amp; rpx &amp; vw (cssrem)，插件设置Root Font Size(默认16)之后，可以自动将px计算成rem，alt+z一键转换\n缺点 需要写多个@media适配尺寸   根标签font-size大小不好把握!!!\n2.flexble适配方案GitHub - amfe-flexible: 可伸缩布局方案\n使用js动态设置rem基准值\n// 核心代码：将屏幕分成多少等分的rem，这里可以根据设计稿自己调整function setRemUnit () &#123;    var rem = docEl.clientWidth / 10    docEl.style.fontSize = rem + &#x27;px&#x27;&#125;\n\n在脚手架中可以配合插件postcss-pxtorem，打包后将px自动转换成rem\n// .postcssrc.js/** * PostCSS 配置文件 */ module.exports = &#123;    // 配置要使用的 PostCSS 插件    plugins: &#123;      // 配置使用 autoprefixer 插件      // 作用：生成浏览器 CSS 样式规则前缀      // VueCLI 内部已经配置了 autoprefixer 插件      // 所以又配置了一次，所以产生冲突了      // &#x27;autoprefixer&#x27;: &#123; // autoprefixer 插件的配置      //   // 配置要兼容到的环境信息      //   browsers: [&#x27;Android &gt;= 4.0&#x27;, &#x27;iOS &gt;= 8&#x27;]      // &#125;,        // 配置使用 postcss-pxtorem 插件      // 作用：把 px 转为 rem      &#x27;postcss-pxtorem&#x27;: &#123;        rootValue (&#123; file &#125;) &#123;           return file.indexOf(&#x27;vant&#x27;) !== -1 ? 37.5 : 75 // 根据条件设置        &#125;, // 表示根元素字体大小，它会根据根元素大小进行单位转换        propList: [&#x27;*&#x27;] // 用来设定可以从 px 转为 rem 的属性      &#125;    &#125;  &#125;\n\n由于viewport单位得到众多浏览器的兼容，lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。\n3.viewport 适配方案设置viewport meta 标记来控制视口大小等于设备宽度，并且不允许手动缩放。\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maxmun-scale=1.0, user-scalable=0&quot; /&gt;\n-    - vw：视口的最大宽度，1vw&#x3D;视口宽度的百分之一；\ntxt- vh：视口得最大高度，1vh=视口高度的百分之一；\n\n- vmin：视口高度 vw 和宽度 vh 两者之间的最小值。\n\n- vmax：视口高度 vw 和宽度 vh 两者之间的最大值。// 假设屏幕宽度为750html &#123;\twidth: 100vw; // 750px&#125;\n\n在脚手架中可以配合插件postcss-px-to-viewport，打包后将px自动转换成vw\n4.scale缩放适配方案多用于大屏数据可视化项目\n取屏幕宽高和设计稿宽高相比中最小的比例对外层盒子进行缩放并居中\n#scaleContainer &#123;    position: absolute;    left: 50%;    top: 50%;&#125;\n\n// 设计稿的宽度let desginWidth = 1920;let desginHeight = 1080;document.getElementById(&#x27;scaleContainer&#x27;).style.width = `$&#123;desginWidth&#125;px`;document.getElementById(&#x27;scaleContainer&#x27;).style.height = `$&#123;desginHeight&#125;px`;function setScale() &#123;    let trueWidth = window.innerWidth;    let trueHeight = window.innerHeight;    let wScale = trueWidth / desginWidth;    let hScale = trueHeight / desginHeight;    let scale = Math.min(wScale, hScale);    document.getElementById(&#x27;scaleContainer&#x27;).style.transform = `scale($&#123;scale&#125;) translate(-50%, -50%)`;&#125;window.addEventListener(&#x27;resize&#x27;, setScale);setScale();\n\nvue项目可以使用v-scale-screen插件\n缺点：当屏幕尺寸比例差距过大会有空白，以及模糊的效果。\n总结：\n移动端推荐使用viewport适配方案\npc端或者响应式推荐@media搭配各种单位\n大屏可视化推荐使用scale缩放\n","slug":"屏幕适配方案","date":"2024-05-18T02:26:36.000Z","categories_index":"html&css","tags_index":"html&css","author_index":"M"},{"id":"318aeaee046984c3662b395e9f7232a5","title":"EyeDropper API","content":"创意应用通常允许用户从应用程序中的绘图或形状中取样颜色以便重用。Web 应用程序可以利用 EyeDropper API，通过浏览器提供类似的拾色器模式。\n使用该 API，Web 应用程序可以启动拾色器模式。一旦启动，光标会变化以提示用户拾色器模式处于活动状态。用户可以从屏幕上的任意位置选择颜色，或者按下 Escape 键取消拾色器模式。\n该 API 不允许在没有用户意图的情况下启动拾色器模式。只能在用户操作（例如按钮点击）的响应中调用 EyeDropper.prototype.open() 方法。\n在没有用户新的意图的情况下，无法再次获取任何像素信息。由 EyeDropper.prototype.open() 返回的 Promise 只会在用户操作（例如点击像素）的响应中返回一个颜色值。因此，无法在用户不知情的情况下在后台使用拾色器。\n为了帮助用户更容易地注意到拾色器模式，浏览器会提供明显的提示。在启动拾色器模式后，正常的鼠标光标会在短暂延迟后消失，取而代之的是一个放大镜图标。此外，拾色器模式开始和用户能够选择像素之间存在一段延迟，以确保用户有足够的时间看到放大镜图标。用户还可以随时取消拾色器模式（通过按下 Escape 键）。\nbtn.addEventListener(&quot;click&quot;, async () =&gt; &#123;    // 监听按钮的点击事件    try &#123;      const result = await eyeDropper.open(); // 开始拾取颜色      console.log(result);      const colorHexValue = result.sRGBHex;      console.log(colorHexValue); // 打印出颜色的值      droppertext.innerText = colorHexValue;      document.body.style.background = colorHexValue;    &#125; catch (e) &#123;      console.log(&quot;用户取消了取色&quot;);    &#125;  &#125;);\n\nEyeDropper–codepen;\n","slug":"EyeDropper","date":"2024-03-02T07:01:12.000Z","categories_index":"javascript","tags_index":"Web API","author_index":"M"},{"id":"da362a96629596348f7f7dfa7c5960d5","title":"Web Animation API","content":"简单写一个例子记录一下 Web Animation API,\nanimate (array,Object);\narray: 主要传一个动画数组对象，来定义动画，对象里可以传 offest 定义时间关键帧\nobject：{duration: 1000, &#x2F;&#x2F;动画时间fill: “forwards”, &#x2F;&#x2F; 同 animation-fill-modeeasing: ‘ease-in-out’ &#x2F;&#x2F;动画速度曲线,同animation-timing-function}\n主要代码，书写方式和 css 动画相似，比较好上手\nfunction moveBall(x, y) &#123;  const rect = ball.getBoundingClientRect();  const ballX = rect.left + rect.width / 2;  const ballY = rect.top + rect.height / 2;  ball.getAnimations().forEach((animation) =&gt; &#123;    animation.cancel();  &#125;);  const rad = Math.atan2(y - ballY, x - ballX);  const deg = (rad * 180) / Math.PI;  ball.animate(    [      &#123;        transform: `translate($&#123;ballX&#125;px, $&#123;ballY&#125;px) rotate($&#123;deg&#125;deg)`,      &#125;,      &#123;        transform: `translate($&#123;ballX&#125;px, $&#123;ballY&#125;px) rotate($&#123;deg&#125;deg) scaleX(1.5)`,        offset: 0.6,      &#125;,      &#123;        transform: `translate($&#123;x&#125;px, $&#123;y&#125;px) rotate($&#123;deg&#125;deg) scaleX(1.5)`,        offset: 0.8,      &#125;,      &#123;        transform: `translate($&#123;x&#125;px, $&#123;y&#125;px) rotate($&#123;deg&#125;deg)`,      &#125;,    ],    &#123;      duration: 1000,      fill: &quot;forwards&quot;,      easing: &quot;ease-in-out&quot;,    &#125;  );&#125;\n\n总结:\nWeb Animation 是原生支持的性能更好。运行中不改变 dom，不占用主线程，性能好。\nanimation-ball-codepen\n","slug":"web-animation","date":"2024-02-25T08:37:38.000Z","categories_index":"javascript","tags_index":"Web API","author_index":"M"},{"id":"90855528bf80b04a5ecf54c5c2be2ee5","title":"slidePicker滑动选择组件封装","content":"记录一下最近封装的滑动选择器组件，支持滑动选择，支持单列，多列、无限滚动。\n外层组件\n&lt;template&gt;  &lt;div class=&quot;picker-box&quot; :style=&quot;&#123; height: boxHeight + &#x27;px&#x27; &#125;&quot;&gt;    &lt;template v-for=&quot;(item, index) in selectArr&quot;&gt;      &lt;PickerItem        :key=&quot;index&quot;        :listData=&quot;item&quot;        :type=&quot;type&quot;        :itemHeight=&quot;itemHeight&quot;        :currentData=&quot;currentData[index]&quot;        :time=&quot;time&quot;        :boxHeight=&quot;boxHeight&quot;        @selectChange=&quot;selectChange(index, $event)&quot;      &gt;&lt;/PickerItem&gt;    &lt;/template&gt;    &lt;div      class=&quot;picker-box__mask-top picker-box__mask&quot;      :style=&quot;&#123; height: maskHeight &#125;&quot;    &gt;&lt;/div&gt;    &lt;div      class=&quot;picker-box__mask-bottom picker-box__mask&quot;      :style=&quot;&#123; height: maskHeight &#125;&quot;    &gt;&lt;/div&gt;    &lt;div      class=&quot;picker-box__border&quot;      :class=&quot;&#123; &#x27;picker-box__border-bg&#x27;: borderBg &#125;&quot;      :style=&quot;&#123; height: itemHeight + &#x27;px&#x27; &#125;&quot;    &gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import PickerItem from &quot;./components/PickerItem/index.vue&quot;;export default &#123;  name: &quot;SlidePicker&quot;,  components: &#123;    PickerItem,  &#125;,  props: &#123;    boxHeight: &#123;      type: Number,      default: 216,    &#125;,    selectArr: &#123;      type: Array,      default: () =&gt; [],    &#125;,    type: &#123;      type: String,      default: &quot;normal&quot;, // normal为非无限滚动，infinite为无限滚动    &#125;,    itemHeight: &#123;      type: Number,      default: 46,    &#125;,    currentData: &#123;      type: Array,      default: () =&gt; [],    &#125;,    time: &#123;      type: Number,      default: 300,    &#125;,    borderBg: &#123;      type: Boolean,      default: false,    &#125;,  &#125;,  data() &#123;    return &#123;      changeData: [],    &#125;;  &#125;,  mounted() &#123;&#125;,  watch: &#123;&#125;,  computed: &#123;    maskHeight() &#123;      return `$&#123;this.boxHeight / 2 - this.itemHeight / 2&#125;px`;    &#125;,    indicatorStyle() &#123;      return `height: $&#123;this.itemHeight&#125;px;`;    &#125;,  &#125;,  methods: &#123;    selectChange(index, event) &#123;      if (this.changeData.length &lt; this.selectArr.length) &#123;        this.changeData.push(event);      &#125; else &#123;        this.changeData.forEach((item) =&gt; &#123;          if (item.value !== event.value) &#123;            this.$set(this.changeData, index, event);          &#125;        &#125;);      &#125;      this.$emit(&quot;selectChange&quot;, this.changeData);    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;@import &quot;../../common/style/theme.less&quot;;.picker-box &#123;  width: 100%;  height: 216px;  display: flex;  overflow: hidden;  position: relative;  &amp;__mask &#123;    width: 100%;    position: absolute;    left: 0;    z-index: 3;    pointer-events: none;    transform: translateZ(1px);    &amp;-top &#123;      top: 0;      background-image: linear-gradient(        to top,        rgba(255, 255, 255, 0.5) 0%,        rgba(255, 255, 255, 0.9) 100%      );    &#125;    &amp;-bottom &#123;      bottom: 0;      background-image: linear-gradient(        to bottom,        rgba(255, 255, 255, 0.5) 0%,        rgba(255, 255, 255, 0.9) 100%      );    &#125;  &#125;  .picker-mask &#123;    background: none !important;  &#125;  &amp;__border &#123;    overflow: hidden;    pointer-events: none;    position: absolute;    left: 0;    right: 0;    top: 50%;    transform: translateY(-50%);    z-index: 4;    &amp;::after,    &amp;::before &#123;      content: &quot;&quot;;      width: 100%;      height: 1px;      background-color: rgba(0, 0, 0, 0.1);      transform: scaleY(0.5);      transform-origin: 0 0;      position: absolute;      left: 0;    &#125;    &amp;::after &#123;      top: 0;    &#125;    &amp;::before &#123;      bottom: 0;    &#125;    &amp;.picker-box__border-bg &#123;      width: calc(100% - 16px);      margin: 0 8px;      border-radius: 8px;      background-color: rgba(0, 0, 0, 0.05);      background-image: none;      &amp;::after,      &amp;::before &#123;        display: none;      &#125;    &#125;  &#125;&#125;&lt;/style&gt;\n\n子组件\n&lt;template&gt;  &lt;div class=&quot;picker-item&quot; ref=&quot;pickeritem&quot;&gt;    &lt;div class=&quot;picker-list&quot;&gt;      &lt;div        class=&quot;picker-ul&quot;        ref=&quot;list&quot;        :style=&quot;&#123; height: itemHeight + &#x27;px&#x27;, top: ulTop &#125;&quot;      &gt;        &lt;div          class=&quot;picker-list-item&quot;          v-for=&quot;(el, index) in renderData&quot;          :class=&quot;&#123; hidden: setHidden(el.index) &#125;&quot;          :style=&quot;&#123; height: itemHeight + &#x27;px&#x27; &#125;&quot;          :key=&quot;index&quot;        &gt;          &#123;&#123; el.text &#125;&#125;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div      class=&quot;picker-wheel&quot;      ref=&quot;wheel&quot;      :style=&quot;&#123; height: itemHeight + &#x27;px&#x27;, top: ulTop &#125;&quot;    &gt;      &lt;div        class=&quot;picker-wheel-item&quot;        :class=&quot;&#123; hidden: setHidden(el.index) &#125;&quot;        :style=&quot;&#123;          height: itemHeight + &#x27;px&#x27;,          transform: setWheelItemDeg(el.index),        &#125;&quot;        :index=&quot;el.index&quot;        v-for=&quot;(el, index) in renderData&quot;        :key=&quot;index&quot;      &gt;        &#123;&#123; el.text &#125;&#125;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  export default &#123;  name: &#x27;PickerItem&#x27;,  data() &#123;    return &#123;      spin: &#123; start: -9, end: 9, branch: 9 &#125;,      finger: &#123; startY: 0, lastY: 0, startTime: 0, lastTime: 0, transformY: 0 &#125;,      flag: true,    &#125;;  &#125;,  props: &#123;    boxHeight: &#123;      type: Number,    &#125;,    listData: &#123;      type: Array,      default: () =&gt; [],    &#125;,    type: &#123;      type: String,    &#125;,    itemHeight: &#123;      type: Number,    &#125;,    currentData: &#123;      type: Object,    &#125;,    time: &#123;      type: Number,    &#125;,  &#125;,  computed: &#123;    renderData() &#123;      const temp = [];      for (let k = this.spin.start; k &lt;= this.spin.end; k++) &#123;        const data = &#123;          text: this.getSpinData(k).text,          index: k,        &#125;;        temp.push(data);      &#125;      return temp;    &#125;,    ulTop() &#123;      return `$&#123;this.boxHeight / 2 - this.itemHeight / 2&#125;px`;    &#125;,  &#125;,  mounted() &#123;    this.$refs.pickeritem.addEventListener(&#x27;touchstart&#x27;, this.itemTouchStart);    this.$refs.pickeritem.addEventListener(&#x27;touchmove&#x27;, this.itemTouchMove);    this.$refs.pickeritem.addEventListener(&#x27;touchend&#x27;, this.itemTouchEnd);    this.init();  &#125;,  watch: &#123;    currentData: &#123;      handler(newVal, oldVal) &#123;        if (newVal !== oldVal &amp;&amp; this.flag) &#123;          this.init();        &#125;      &#125;,      immediate: true,    &#125;,  &#125;,  methods: &#123;    init() &#123;      this.$nextTick(() =&gt; &#123;        let index;        let move;        let value;        value = this.currentData?.value || &#x27;&#x27;;        this.finger = &#123; startY: 0, lastY: 0, startTime: 0, lastTime: 0, transformY: 0 &#125;;        index = this.listData.findIndex(item =&gt; item.value == value);        if (index === -1) &#123;          this.setListTransform();          this.getPickValue(0);        &#125; else &#123;          move = index * this.itemHeight;          this.setStyle(-move);          this.setListTransform(-move, -move);          this.getPickValue(-move);        &#125;      &#125;);    &#125;,    setHidden(index) &#123;      if (this.type === &#x27;normal&#x27;) &#123;        return index &lt; 0 || index &gt; this.listData.length - 1;      &#125;      return false;    &#125;,    setWheelItemDeg(index) &#123;      return `rotate3d(1, 0, 0, $&#123;(-index * 20) % 360&#125;deg) translate3d(0px, 0px, $&#123;`$&#123;        2.8 * this.itemHeight      &#125;px`&#125;)`;    &#125;,    setWheelDeg(updateDeg, type, time = this.time) &#123;      if (type === &#x27;infinite&#x27;) &#123;        this.$refs.wheel.style.transition = `transform $&#123;time&#125;ms ease-out`;        this.$refs.wheel.style.transform = `rotate3d(1, 0, 0, $&#123;updateDeg&#125;deg)`;      &#125; else &#123;        this.$refs.wheel.style.transition = &#x27;&#x27;;        this.$refs.wheel.style.transform = `rotate3d(1, 0, 0, $&#123;updateDeg&#125;deg)`;      &#125;    &#125;,    setListTransform(translateY = 0, marginTop = 0, type, time = this.time) &#123;      if (type === &#x27;infinite&#x27;) &#123;        this.$refs.list.style.transition = `transform $&#123;time&#125;ms ease-out`;        this.$refs.list.style.transform = `translateY($&#123;translateY - this.spin.branch * this.itemHeight&#125;px)`;        this.$refs.list.style.marginTop = `$&#123;-marginTop&#125;px`;        this.$refs.list.setAttribute(&#x27;scroll&#x27;, translateY);      &#125; else &#123;        this.$refs.list.style.transition = &#x27;&#x27;;        this.$refs.list.style.transform = `translateY($&#123;translateY - this.spin.branch * this.itemHeight&#125;px)`;        this.$refs.list.style.marginTop = `$&#123;-marginTop&#125;px`;        this.$refs.list.setAttribute(&#x27;scroll&#x27;, translateY);      &#125;    &#125;,    itemTouchStart(event) &#123;      this.flag = false;      let finger = event.changedTouches[0];      this.finger.startY = finger.pageY;      this.finger.startTime = event.timeStamp || Date.now();      this.finger.transformY = this.$refs.list.getAttribute(&#x27;scroll&#x27;);      event.preventDefault();    &#125;,    itemTouchMove(event) &#123;      let finger = event.changedTouches[0];      this.finger.lastY = finger.pageY;      this.finger.lastTime = event.timeStamp || Date.now();      const move = this.finger.lastY - this.finger.startY;      this.setStyle(move);      event.preventDefault();    &#125;,    itemTouchEnd(event) &#123;      let finger = event.changedTouches[0];      this.finger.lastY = finger.pageY;      this.finger.lastTime = event.timeStamp || Date.now();      let move = this.finger.lastY - this.finger.startY;      let time = this.finger.lastTime - this.finger.startTime;      const v = move / time;      const a = 2.6;      if (time &lt;= 300) &#123;        move = v * a * time;        time = this.time + time * a;        this.setStyle(move, &#x27;infinite&#x27;, time);      &#125; else &#123;        this.setStyle(move, &#x27;infinite&#x27;);      &#125;      // 由于长按时watch监听的currentData会多次触发init事件，这里等滑动结束再触发。        setTimeout(() =&gt; &#123;          this.flag = true;        &#125;, this.time);    &#125;,    setStyle(move, type, time) &#123;      const singleHeight = this.itemHeight;      const deg = 20;      const singleDeg = deg / singleHeight;      const currentListMove = this.finger.transformY;      let updateMove = move + Number(currentListMove);      let updateDeg;      let spinAim;      let margin;      let endMove;      let endDeg;      if (type === &#x27;infinite&#x27; &amp;&amp; this.type === &#x27;normal&#x27;) &#123;        if (updateMove &gt; 0) &#123;          updateMove = 0;        &#125;        if (updateMove &lt; -(this.listData.length - 1) * singleHeight) &#123;          updateMove = -(this.listData.length - 1) * singleHeight;        &#125;      &#125;      updateDeg = -updateMove * singleDeg;      spinAim = Math.round(updateDeg / 20);      margin = Math.round(updateMove / singleHeight) * singleHeight;      endMove = margin;      endDeg = Math.round(updateDeg / deg) * deg;      if (type === &#x27;infinite&#x27;) &#123;        this.setListTransform(endMove, margin, type, time);        this.setWheelDeg(endDeg, type, time);        setTimeout(() =&gt; this.getPickValue(endMove), this.time);      &#125; else &#123;        this.setListTransform(updateMove, margin);        this.setWheelDeg(updateDeg);      &#125;      this.updateSpin(spinAim);    &#125;,    updateSpin(spinAim) &#123;      this.spin.start = this.spin.branch * -1 + spinAim;      this.spin.end = this.spin.start + this.spin.branch * 2;    &#125;,    getSpinData(index) &#123;      index = index % this.listData.length;      return this.listData[index &gt;= 0 ? index : index + this.listData.length];    &#125;,    getPickValue(move) &#123;      const index = Math.round(-move / this.itemHeight);      const pickValue = this.getSpinData(index);      this.$emit(&#x27;selectChange&#x27;, pickValue);    &#125;,  &#125;,  beforeDestroy() &#123;    this.$refs.pickeritem.removeEventListener(&#x27;touchstart&#x27;, this.itemTouchStart);    this.$refs.pickeritem.removeEventListener(&#x27;touchmove&#x27;, this.itemTouchMove);    this.$refs.pickeritem.removeEventListener(&#x27;touchend&#x27;, this.itemTouchEnd);  &#125;,&#125;;&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;.picker &#123;  &amp;-item &#123;    width: 100%;    height: 100%;    text-align: center;    overflow: hidden;    position: relative;    &amp; ul,    li &#123;      padding: 0;      list-style: none;      margin: 0;    &#125;  &#125;  &amp;-ul &#123;    position: relative;  &#125;  &amp;-list,  &amp;-wheel &#123;    position: absolute;    left: 0;    right: 0;    top: 82px;  &#125;  &amp;-wheel &#123;    z-index: 1;  &#125;  &amp;-list &#123;    overflow: hidden;  &#125;  &amp;-list-item,  &amp;-wheel-item &#123;    display: flex;    align-items: center;    justify-content: center;    white-space: nowrap;    overflow: hidden;    text-overflow: ellipsis;    font-size: 17px;    color: #000;    &amp;.hidden &#123;      visibility: hidden;      opacity: 0;    &#125;  &#125;  &amp;-list-item &#123;    color: transparent !important;  &#125;  &amp;-wheel &#123;    transform-style: preserve-3d;    height: 46px;    &amp;-item &#123;      backface-visibility: hidden;      -webkit-backface-visibility: hidden;      position: absolute;      top: 0;      width: 100%;    &#125;  &#125;&#125;&lt;/style&gt;\n\n写的比较菜，凑合着看👀吧\n","slug":"slidePicker","date":"2024-01-27T10:21:06.000Z","categories_index":"vue","tags_index":"components","author_index":"M"},{"id":"5ec98a85a99b57e340a9a2a9ff61c2c1","title":"封装canvas画分享图能力","content":"整理了一下工作中封装的画分享海报的能力\nclass ShareCanvas &#123;    constructor(config) &#123;        this.width = config.width || 375;        this.height = config.height || 616;        this.scale = config.scale || 3;        this.canvasDom = document.createElement(&#x27;canvas&#x27;);        this.ctx = this.canvasDom.getContext(&#x27;2d&#x27;);        this.canvasDom.width = this.width * this.scale;        this.canvasDom.height = this.height * this.scale;        if (!config?.hidden) &#123;            document.body.appendChild(this.canvasDom);        &#125;    &#125;    /**     *     * url  图片url     * x x轴     * y  y轴     * width 图片宽度     * height 图片高     * radius  传值则画圆角图片     * rotate 旋转     */    drawImg(config) &#123;        let promise = new Promise((resolve, reject) =&gt; &#123;            let img = new Image();            img.onload = () =&gt; &#123;                if (config.bgColor) &#123;                    this.ctx.fillStyle = config.bgColor;                    this.ctx.fillRect(0, 0, config.x * this.scale, config.y * this.scale);                    this.ctx.restore();                    return;                &#125;                this.ctx.save();                if (config.filter) &#123;                    this.ctx.filter = config.filter;                &#125;                if (config.opacity) &#123;                    this.ctx.globalAlpha = config.opacity;                &#125;                if (config.radius) &#123;                    // 传radius可画圆角头像                    config.radius = config.radius * this.scale;                    config.x = config.x * this.scale;                    config.y = config.y * this.scale;                    // this.ctx.save();                    this.ctx.beginPath();                    const size = 2 * config.radius;                    this.ctx.arc(config.x, config.y, config.radius, 0, 2 * Math.PI);                    this.ctx.clip();                    this.ctx.drawImage(img, (config.x - config.radius), (config.y - config.radius), size, size);                    // this.ctx.restore();                &#125; else &#123;                    if(config.rotate) &#123;                        let rotateX = config.x;                        let rotateY = config.y;                        let offsetX = 0;                        let offsetY = 0;                        // 围绕图片中心点旋转                        if (config.rotateAroundCenter) &#123;                            offsetX = config.width / 2;                            offsetY = config.height / 2;                            rotateX += offsetX;                            rotateY += offsetY;                        &#125;                        this.ctx.save();                        this.ctx.translate(rotateX * this.scale, rotateY * this.scale);                        this.ctx.rotate(config.rotate * Math.PI / 180);                        this.drawBorderRadius(config);                        this.ctx.drawImage(img, -offsetX, -offsetY, (config.width || this.width) * this.scale, (config.height || this.height) * this.scale);                        this.ctx.setTransform(1, 0, 0, 1, 0, 0);                        // this.ctx.restore();                    &#125; else &#123;                        this.drawBorderRadius(config);                        this.ctx.drawImage(img, config.x * this.scale, config.y * this.scale, (config.width || this.width) * this.scale, (config.height || this.height) * this.scale);                    &#125;                &#125;                this.ctx.restore();                resolve();            &#125;;            img.onerror = (e) =&gt; &#123;                reject(e);            &#125;;            img.setAttribute(&#x27;crossOrigin&#x27;, &#x27;anonymous&#x27;);            img.src = config.url;        &#125;);        return promise;    &#125;    drawTextWithShadow(cssStyle, text, x, y) &#123;        // 解析CSS样式        const styleParts = cssStyle.split(&#x27;,&#x27;).map((part) =&gt; part.trim());        const shadowStyles = styleParts.map((part) =&gt; &#123;            const [offsetX, offsetY, color] = part.split(&#x27; &#x27;);            return &#123;                offsetX: parseFloat(offsetX),                offsetY: parseFloat(offsetY),                color,            &#125;;        &#125;);        // 绘制字体描边        shadowStyles.forEach((style) =&gt; &#123;            this.ctx.shadowOffsetX = style.offsetX;            this.ctx.shadowOffsetY = style.offsetY;            this.ctx.shadowColor = style.color;            this.ctx.fillText(text, x, y);        &#125;);        // 绘制字体本身        this.ctx.shadowColor = &#x27;transparent&#x27;; // 清除阴影设置        this.ctx.fillText(text, x, y);        // this.ctx.restore();    &#125;    drawBorderRadius(config) &#123;        if (config.border_radius) &#123;            // 绘制圆角图片            const borderRadius = config.border_radius;            const x = config.x;            const y = config.y;            const width = config.width;            const height = config.height;            // this.ctx.save();            this.ctx.beginPath();            this.ctx.moveTo(x + borderRadius, y);            this.ctx.lineTo(x + width - borderRadius, y);            this.ctx.arcTo(x + width, y, x + width, y + borderRadius, borderRadius);            this.ctx.lineTo(x + width, y + height - borderRadius);            this.ctx.arcTo(x + width, y + height, x + width - borderRadius, y + height, borderRadius);            this.ctx.lineTo(x + borderRadius, y + height);            this.ctx.arcTo(x, y + height, x, y + height - borderRadius, borderRadius);            this.ctx.lineTo(x, y + borderRadius);            this.ctx.arcTo(x, y, x + borderRadius, y, borderRadius);            this.ctx.closePath();            this.ctx.clip();            // this.ctx.restore();        &#125;    &#125;    filterText(str, width, x, y, fixedText = &#x27;&#x27;, tail = 10, isStroke, right, bottom, textShadow) &#123;        const widthBox = (width || this.width) * this.scale;        const fixedTextWidth = this.ctx.measureText(fixedText).width;        let maxWidth = (widthBox - (tail * this.scale)) - fixedTextWidth;        let strWidth = this.ctx.measureText(str).width;        const ellipsis = &#x27;... &#x27;;        const ellipsisWidth = this.ctx.measureText(ellipsis).width;        let text = &#x27;&#x27;;        if (strWidth &lt;= maxWidth || maxWidth &lt;= ellipsisWidth) &#123;            text = str + fixedText;        &#125; else &#123;            let len = str.length;            while (strWidth &gt;= maxWidth - ellipsisWidth &amp;&amp; len-- &gt; 0) &#123;                str = str.slice(0, len);                strWidth = this.ctx.measureText(str).width;            &#125;            text = str + ellipsis + fixedText;        &#125;        let finalX = x * this.scale;        let finalY = y * this.scale;        // 没有传x且传了right, 就按right去定位        if (!x &amp;&amp; right) &#123;            finalX = widthBox - right;        &#125;        // 没有传y且传了bottom, 就按bottom去定位        if (!y &amp;&amp; bottom) &#123;            finalY = this.height * this.scale - bottom;        &#125;        if (textShadow) &#123;            this.drawTextWithShadow(textShadow, text, finalX, finalY);        &#125; else if (isStroke) &#123;            this.ctx.fillText(text, finalX, finalY);            this.ctx.strokeText(text, finalX, finalY);        &#125; else &#123;            this.ctx.fillText(text, finalX, finalY);        &#125;        this.ctx.restore();        return text;    &#125;    filterMultiLineText(config, x, y, isStroke) &#123;        const &#123; lineHeight, text, lineLimit, fontSize, whiteSpace, textShadow &#125; = config || &#123;&#125;;        if (!lineHeight) return;        let textRows = [];        if (whiteSpace &amp;&amp; whiteSpace.indexOf(&#x27;pre&#x27;) !== -1) &#123;            textRows = text.split(&#x27;\\n&#x27;);        &#125; else if (lineLimit) &#123;            for (let i = 0; i &lt; text.length; i += lineLimit) &#123;                textRows.push(text.substring(i, i + lineLimit));            &#125;        &#125;        const finalX = x * this.scale;        let finalY = (y - fontSize) * this.scale;        for (let i = 0; i &lt; textRows.length; i++) &#123;            const line = textRows[i];            this.ctx.textBaseline = &#x27;top&#x27;;            if (textShadow) &#123;                this.drawTextWithShadow(textShadow, line, finalX, finalY);            &#125; else if (isStroke) &#123;                this.ctx.fillText(line, finalX, finalY);                this.ctx.strokeText(line, finalX, finalY);            &#125; else &#123;                this.ctx.fillText(line, finalX, finalY);            &#125;            finalY += lineHeight * this.scale;        &#125;        this.ctx.restore();        return text;    &#125;    /**        text: 文字        x: x轴        y: y轴        right: 距离右边的距离        bottom: 距离下边的距离        width: 文字宽度        color: 文字颜色        fontSize: 文字大小        strokeColor: 描边颜色        lineWidth: 描边宽度        fontFamily: 字体        fontBold: 字体是否加粗        textAlign: 文字对齐方式        lineHeight: 行高        shadowColor: 文字阴影颜色        shadowOffsetX: 文字阴影x轴        shadowOffsetY: 文字阴影y轴        shadowBlur: 文字阴影模糊        letterSpacing 文字间距        rotate 旋转    */    strokeText(config) &#123;        const textAlign = config.textAlign || &#x27;center&#x27;;        // 当x为0或者未传时，重新设置x，使文字能在容器内呈现与html css样式一样的效果        // 不重写的话，当x为0，textaligh为center时，文字将超出屏幕只画一半        const finalWidth = config.width || this.width * this.scale;        const &#123; bottom, right, rotate &#125; = config;        let finalX = config.x;        let finalY = config.y;        if (!finalX &amp;&amp; !right) &#123;            if (textAlign === &#x27;center&#x27;) &#123;                finalX = finalWidth / 2;            &#125; else if (textAlign === &#x27;right&#x27;) &#123;                finalX = finalWidth;            &#125;        &#125;        this.ctx.textAlign = textAlign ;        this.ctx.save();        if (rotate) &#123;            this.ctx.translate(finalX, finalY);            this.ctx.rotate(rotate * Math.PI / 180);            finalX = 0;            finalY = 0;        &#125;        if (config.strokeColor) &#123;            this.ctx.strokeStyle = config.strokeColor;            this.ctx.lineWidth = config.lineWidth;            this.ctx.font = `$&#123;config.fontBold || &#x27;400&#x27;&#125; $&#123;(config.fontSize || 17) * this.scale&#125;px $&#123;config.fontFamily || &#x27;PingFang SC&#x27;&#125;`;            this.ctx.fillStyle = config.color || &#x27;rgba(255, 255, 255, 1)&#x27;;            if (config.lineHeight || config.whiteSpace === &#x27;pre&#x27;) &#123;                this.filterMultiLineText(config, finalX, finalY, true);            &#125; else &#123;                this.filterText(config.text, finalWidth, finalX, finalY, &#x27;&#x27;, 10, true, right, bottom, config.textShadow);            &#125;        &#125; else &#123;            if (config.shadowColor) &#123;                const &#123; shadowColor, shadowOffsetX, shadowOffsetY, shadowBlur &#125; = config;                this.ctx.shadowColor = shadowColor;                this.ctx.shadowOffsetX = shadowOffsetX;                this.ctx.shadowOffsetY = shadowOffsetY;                this.ctx.shadowBlur = shadowBlur;            &#125;;            this.ctx.fillStyle = config.color || &#x27;rgba(255, 255, 255, 1)&#x27;;            this.canvasDom.style.letterSpacing = config.letterSpacing || &#x27;0px&#x27;;            this.ctx.font = `$&#123;config.fontBold || &#x27;400&#x27;&#125; $&#123;(config.fontSize || 17) * this.scale&#125;px $&#123;config.fontFamily || &#x27;PingFang SC&#x27;&#125;`;            if (config.lineHeight || config.whiteSpace === &#x27;pre&#x27;) &#123;                this.filterMultiLineText(config, finalX, finalY, false);            &#125; else &#123;                this.filterText(config.text, finalWidth, finalX, finalY, &#x27;&#x27;, 10, false, right, bottom, config.textShadow);            &#125;        &#125;    &#125;    /**        x: x轴        y: y轴        width: 矩形宽度        height: 文字颜色        radius: 矩形的圆角        linewidth: 描边宽度        fillColor: 填充颜色        strokeColor: 描边颜色    */    roundReact(reactConfig) &#123;        // 圆角矩形        const x = reactConfig.x * this.scale;        const y = reactConfig.y * this.scale;        const width = reactConfig.width * this.scale;        const height = reactConfig.height * this.scale;        const radius = (reactConfig.radius || 0) * this.scale;        this.ctx.beginPath();        this.ctx.lineWidth = (reactConfig.lineWidth || 0) * this.scale;        this.ctx.moveTo(x + radius, y);        this.ctx.lineTo(x + width - radius, y);        this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);        this.ctx.lineTo(x + width, y + height - radius);        this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);        this.ctx.lineTo(x + radius, y + height);        this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);        this.ctx.lineTo(x, y + radius);        this.ctx.quadraticCurveTo(x, y, x + radius, y);        this.ctx.fillStyle = reactConfig.fillColor || &#x27;rgba(0, 0, 0, 0.5)&#x27;;        this.ctx.strokeStyle = reactConfig.strokeColor || &#x27;rgba(0, 0, 0, 0)&#x27;;        this.ctx.closePath();        this.ctx.fill();        this.ctx.stroke();    &#125;    /**        width: 矩形宽度        height: 文字颜色        bgColor: 背景颜色    */    fillColor(config) &#123;        if (!config?.bgColor) &#123;            return;        &#125;        const width = config.width * this.scale;        const height = config.height * this.scale;        this.ctx.fillStyle = config.bgColor;        this.ctx.fillRect(0, 0, width, height);        this.ctx.restore();    &#125;    toDataURL() &#123;        return this.canvasDom.toDataURL(&#x27;image/png&#x27;, 1);    &#125;    updateInstance(config) &#123;        this.width = config.width || 375;        this.height = config.height || 616;        this.scale = config.scale || 3;        this.canvasDom.width = this.width * this.scale;        this.canvasDom.height = this.height * this.scale;    &#125;&#125;","slug":"canvas-screenshot","date":"2023-08-20T09:18:20.000Z","categories_index":"canvas","tags_index":"canvas","author_index":"M"},{"id":"75d3376298d1a1243774695d34b2245b","title":"tabList切换动画","content":"简单记录一下这个 tab 切换场景，切换 tab 时底部背景带动画切换效果，tab 自动滚动。\ninitBg(index) &#123;    const tabItem = document.querySelectorAll(&#x27;.tab__inner-item&#x27;);    const &#123; tab &#125; = this.$refs;    const tbBg = this.$refs.tabbg;    if (!tabItem[index] &amp;&amp; !tab) &#123;        return;    &#125;    this.$nextTick(() =&gt; &#123;        tbBg.style.left = `$&#123;Math.ceil(tabItem[index]?.offsetLeft)&#125;px`;        tbBg.style.width = `$&#123;Math.ceil(tabItem[index]?.getBoundingClientRect()?.width)&#125;px`;        const x = Math.ceil(tabItem[index]?.getBoundingClientRect()?.x);        const scrollL = Math.ceil(tabItem[index]?.offsetLeft);        const width = Math.ceil(tabItem[index]?.getBoundingClientRect()?.width);        const &#123; clientWidth &#125; = tab;        const halfClient = clientWidth / 2;        if (index === 0) &#123;        tab.scrollTo(&#123;            left: 0,            behavior: &#x27;smooth&#x27;,        &#125;);        return;        &#125;        if (index === this.tabList.length - 1) &#123;        tab.scrollTo(&#123;            left: scrollL,            behavior: &#x27;smooth&#x27;,        &#125;);        return;        &#125;        if (x &gt; 0 &amp;&amp; scrollL &gt;= halfClient) &#123;        let r = scrollL - (halfClient - (width / 2));        tab.scrollTo(&#123;            left: r,            behavior: &#x27;smooth&#x27;,        &#125;);        &#125; else &#123;        tab.scrollTo(&#123;            left: 0,            behavior: &#x27;smooth&#x27;,        &#125;);        &#125;    &#125;);&#125;,\n\ntab-codepen;\n","slug":"tab","date":"2023-05-13T08:02:56.000Z","categories_index":"vue","tags_index":"components","author_index":"M"},{"id":"1e50defbd0e228f93ecdc9666a341d83","title":"获取url参数，设置url参数","content":"封装一下 获取 url 参数和设置 url 参数的方法\n//设置url某个参数的方法changeUrlParameter(url, parameterName, newValue) &#123;    const regex = new RegExp(&quot;([?&amp;])&quot; + parameterName + &quot;=.*?(&amp;|$)&quot;, &quot;i&quot;);    if (regex.test(url)) &#123;        return url.replace(regex, &quot;$1&quot; + parameterName + &quot;=&quot; + encodeURIComponent(newValue) + &quot;$2&quot;);    &#125; else &#123;        if (url.indexOf(&quot;?&quot;)!== -1) &#123;            return url + &quot;&amp;&quot; + parameterName + &quot;=&quot; + encodeURIComponent(newValue);        &#125; else &#123;            return url + &quot;?&quot; + parameterName + &quot;=&quot; + encodeURIComponent(newValue);        &#125;    &#125;&#125;\n\n//获取URL某个参数的方法function getUrlParam(paramName) &#123;    const url = window.location.href;    const regex = new RegExp(&#x27;[?&amp;]&#x27; + paramName + &#x27;=([^&amp;#]*)&#x27;);    const match = regex.exec(url);    return match ? decodeURIComponent(match[1]) : null;&#125;","slug":"geturlparam","date":"2023-04-01T05:10:36.000Z","categories_index":"","tags_index":"utils","author_index":"M"},{"id":"62bc8025e0eb197d420ffa98bc79c161","title":"git 常用命令","content":"目前常用的git命令整理\n1，git init\n初始化一个新的Git仓库。\n这将在当前目录中创建一个名为”.git”的子目录，Git会将所有仓库的元数据存储在其中。\n2，git clone\n克隆一个已存在的仓库。\n这会创建一个本地仓库的副本，包括其所有的历史记录和分支。\ngit clone &lt;仓库链接&gt;\n3，git add\n将修改内容添加到下一次提交中。\n这将把指定的文件添加到暂存区，这些文件将包含在下一次提交中。\ngit add file1.txt file2.txt\n4，git commit\n创建一个新的提交。\n这将记录暂存区的修改以及自上次提交以来所做的任何其他修改，并附带一条描述这些修改的提交信息。\ngit commit -m “添加新功能”\ngit commit ‘’ --noverify 取消提交时格式化代码\n5，git push\n将提交推送到远程仓库。\n这将把本地的提交发送到指定的远程仓库，更新远程分支以包含新的提交。\ngit push origin main\n6，git pull\n从远程仓库获取并合并修改。\n这会从指定的远程仓库中获取最新的提交，并将其合并到当前分支中。\ngit pull origin main\n8，git branch\n列出、创建或删除分支。\n这个命令可以用来列出仓库中可用的分支，创建新的分支或删除现有的分支。\ngit branch new-branch\n9，git checkout\n切换到不同的分支。\n这个命令允许你切换到仓库中的不同分支，并将其作为当前工作分支。\ngit checkout main\n10，git merge\n将一个分支合并到另一个分支。\n这个命令将一个分支的修改合并到另一个分支中，创建一个反映合并变化的新提交。\ngit merge new-branch\n11，git status\n显示仓库的状态。\n这个命令会显示当前分支、任何暂存或未暂存的修改以及任何未跟踪的文件。\ngit status\n12，git rebase\n将一个分支的修改合并到另一个分支。\n假设你在”XYZ”分支上进行了一些修改，你希望将这些修改合并到”main”分支中。你可以使用git rebase命令将你的修改重新应用到main分支之上。\n13，git stash\n临时保存还未准备提交的修改。\n如果你的修改还没有准备好提交，但你想要切换到另一个分支继续工作，你可以临时保存你的修改以便以后使用，并在不丢失进度的情况下切换分支。\n（1）git stash save “save message”  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。\n（2）git stash list  ：查看stash了哪些存储\n（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}\n（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@{$num}  -p ，比如第二个：git stash show  stash@{1}  -p\n（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} \n（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}\n（7）git stash drop stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储\n（8）git stash clear ：删除所有缓存的stash\n14，git revert\n假设你在之前的提交中犯了一个错误，需要撤销它。你可以使用git revert创建一个新的提交，该提交会撤销之前提交引入的修改。\ngit revert ..\n15，删除分支\n删除本地分支\ngit branch -D branch\ngit push --delete origin branch\n16, git reset\n回退提交错误的代码\ngit reset --hard log\ngit push -f origin branch\n","slug":"git","date":"2023-03-19T03:23:28.000Z","categories_index":"git","tags_index":"git","author_index":"M"},{"id":"c0b4ed83bb36ebf80bf9643e36e3db7c","title":"记一次git报错","content":"记一次使用git报错，解决Unable to negotiate with **** port 22: no matching host key type found. Their offer: ssh-rsa\nwindows系统，去官网下载了最新的git安装，一路next下来，打开bash按老路子设置，生成公钥\ngit config –global user.name “yourname”\ngit config –global user.email “&#x79;&#x6f;&#x75;&#x72;&#64;&#101;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;“\nssh-keygen -t rsa -C “&#121;&#x6f;&#x75;&#114;&#64;&#101;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;“\n把公钥添加到github，clone代码时拉不下来，报错。\nUnable to negotiate with **** port 22: no matching host key type found. Their offer: ssh-rsafatal: Could not read from remote repository.\nPlease make sure you have the correct access rightsand the repository exists.\n查看自己是开发者权限，重置一遍公钥再添加也不行，去网上找方法，介绍这种情况的原因就是新的ssh客户端不支持ssh-rsa算法，要修改本地配置重新使用ssh-rsa算法。\n具体做法：到当前用户目录下的.ssh文件中创建config文件（config没有后缀），使用记事本打开添加如下\nHost *HostkeyAlgorithms +ssh-rsaPubkeyAcceptedKeyTypes +ssh-rsa","slug":"git-clone-error","date":"2023-03-18T02:26:36.000Z","categories_index":"git","tags_index":"git","author_index":"M"},{"id":"02dffd67a1266aabc62643a303624bae","title":"微信头像九宫格布局","content":"近期写页面遇到需要九宫格布局的情况，研究许久现记录一下布局方式。\n我们知道 flex 布局可以设置flex-wrap: wrap在元素放不下后自动换行，那么设置flex-wrap: wrap-reverse;就可以反过来布局，达到三个头像一个在上的效果啦~\n核心代码\n display: flex;flex-wrap: wrap-reverse;\n\n示例\n\n图片九宫格布局效果-codepen\n","slug":"微信头像九宫格布局","date":"2023-02-25T01:18:41.000Z","categories_index":"html&css","tags_index":"html&css","author_index":"M"},{"id":"9c18a0a19d9da2524bfd7e84c96937b7","title":"白天与黑夜模式切换","content":"通过给body添加类名和prefers-color-scheme方法改变darkmode和lightmode对应的less变量来实现白天与黑夜模式切换。\n定义一个less映射：@colors用来存储颜色的变量，再定义一个less mixin bl_color(@propertyName, @valueName) 快速书写这些变量，从而提高代码的可维护性和复用性。\n@colors: &#123;  //背景颜色  @bl_0: var(--bl_background_color_0);  //文字颜色  @text_0: var(--bl_text_color_0);  //颜色  @bl_red: var(--bl_red);  ...&#125;;.bl_c(@valueName) &#123;  .bl_color(color, @valueName);&#125;.bl_bc(@valueName) &#123;  .bl_color(background-color, @valueName);&#125;.bl_color(@propertyName, @valueName) &#123;  @&#123;propertyName&#125;: @colors[ @@valueName];&#125;\n\n通过css预处理器加js控制添加类名改变变量颜色的方式是兼容性比较好的方式。\n变量兼容性;darkmode &amp; lightmode–codepen\n","slug":"darkmode & lightmode","date":"2023-02-11T06:20:21.000Z","categories_index":"html&css","tags_index":"css","author_index":"M"},{"id":"6437029993a7d71a87cf53a2ebf329e0","title":"Fontmin拆字工具","content":"用户界面（UI）设计中，字体的选择和优化至关重要。一个恰当的字体不仅能够提升用户体验，还能彰显产品特色。然而，大型字体文件包动轨几M十几M，用到的可能就几个字，却要下这么大的字体包，使用体验极差。那么，有没有更好的解决方案呢？答案是肯定的，为了解决这一问题，我们来介绍下今天的主角：Fontmin。\nFontmin是一个字体子集化工具，能够帮助我们优化字体资源，减少数据量，进而加快加载速度，提升UI的流畅性和响应速度。\n什么是Fontmin？\nFontmin是第一个纯 JavaScript 实现的字体子集化方案，专门用于移除字体文件中未使用的字形，从而大幅减少字体文件的体积。\n注意，目前只支持ttf格式的字体。\n用法\n在官网点击下载后，直接双击打开，把ttf字体包拉到左下方，左边拆要用的字体，右边实时显示这个字体样式，拆完后点击生成就好了。\n还可以把拆过的字体包在👇这个网站转成base64格式使用。\ntransfonter\nFontmin官网\n","slug":"Fontmin","date":"2023-01-14T05:25:39.000Z","categories_index":"tools","tags_index":"tools","author_index":"M"},{"id":"28d98cddafd9f6848c3c42b61bb379e5","title":"iOS-switch","content":"iOS开关按钮样式动画效果，包括长按动画，darkmode样式\niOS-switch–codepen\n","slug":"iOS-switch","date":"2023-01-08T04:01:39.000Z","categories_index":"html&css","tags_index":"components","author_index":"M"},{"id":"d75b5e4fd72b55b08ad11edd4621e68d","title":"mask-image","content":"mask-image 属性是CSS中一个用于指定元素遮罩图像的属性。它允许开发者通过图像来遮罩元素的背景或其他图像内容，实现复杂的视觉效果。\nmask-image属性定义了一个图像的遮罩层，该遮罩层将应用于元素的内容上。只有遮罩图像的非透明部分才会显示元素的内容，而透明部分则会隐藏内容。\n比如以下示例，我想实现这个svg图片改变颜色,只有这个svg图片的非透明部分才会显示颜色\n&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;.item &#123;    width: 24px;    height: 24px;    -webkit-mask-image: url(&quot;data:image/svg+xml,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; fill=&#x27;none&#x27; stroke=&#x27;currentColor&#x27; stroke-linecap=&#x27;round&#x27; stroke-linejoin=&#x27;round&#x27; stroke-width=&#x27;2&#x27; viewBox=&#x27;0 0 24 24&#x27;%3E%3Ccircle cx=&#x27;12&#x27; cy=&#x27;12&#x27; r=&#x27;4&#x27;/%3E%3Cpath d=&#x27;M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41&#x27;/%3E%3C/svg%3E&quot;);    /* background-color: #E6AF00; */    background-color: #000;&#125;\n\n简单实现了这个svg图片自定义各种颜色\n还有这些定义mask-image的大小、位置、平铺的属性同 background\n-webkit-mask-size: 100% 100%;-webkit-mask-repeat: no-repeat;-webkit-mask-position: center;\n\n兼容性;mdn\n","slug":"mask-image","date":"2022-12-25T02:49:40.000Z","categories_index":"html&css","tags_index":"css","author_index":"M"},{"id":"c40fd8eb89666f7ca7e92e2c34687b74","title":"getBoundingClientRect","content":"Element.getBoundingClientRect() 方法返回一个 DOMRect 对象，其提供了元素的大小及其相对于视口的位置，指元素(宽高必须设置具体数值)距离可视区域顶部的距离。\n&lt;div class=&quot;box&quot;&gt; &lt;/div&gt; * &#123;  margin: 0;  padding: 0;&#125;.box &#123;  width: 100px;  height: 100px;  background-color: #000;&#125;\n\nDOMRect &#123;    bottom: 100;    height: 100;    left: 0;    right: 100;    top: 0;    width: 100;    x: 0;    y: 0; &#125;\n\n与offset相比.\n以offsetTop为例: offsetTop:返回当前元素相对于 offsetParent（position为非static且距离自己最近的祖先元素，若祖宗都不符合条件，offsetParent为body） 节点顶部边界的偏移像素值。且这个距离不随滚动条滚动变化，也就是说这个距离开始是多少就是多少，是个恒定值（包括滚动条卷起的部分）\n总结： \n当监听的是window的滚动条时，元素的getBoundingClientRect().top会原来越小，而offsetTop一直不变\ngetBoundingClientRect–MDN;\n","slug":"getBoundingClientRect","date":"2022-12-17T08:49:36.000Z","categories_index":"javascript","tags_index":"Web API","author_index":"M"},{"id":"92e648db1789cade1fa84cef6b1bbfe8","title":"逐帧动画实现无限轮播","content":"最近有一个无限滚动轮播的需求，最开始用js+延时器写了一版，但因为是用在首页性能消耗很大，所以想试试能不能用css搞定，嘿，还真发现了一种方法，虽然最后没有使用这种方法，但也学学看吧。\n先看个完成效果\n\n\n我们来简单分析分析，从表面上看，确实好像只有元素的 transform: translate() 在位移，但是注意，这里有两个难点：\n\n这是个无限轮播的效果，我们的动画需要支持任意多个元素的无限轮播切换\n因为是轮播，所以，运行到最后一个的时候，需要动画切到第一个元素\n\n\n\n到这里，你可以暂停思考一下，如果有 20 个元素，需要进行类似的无限轮播播报，使用 CSS 实现，你会怎么去做呢？\n逐帧动画控制整体切换在这里，要实现轮播效果，并且是任意个数，我们可以借助 animation-timing-function: steps()\n:root &#123;  // 轮播的个数  --s: 6;  // 单个 li 容器的高度  --h: 36;  // 单次动画的时长  --speed: 1.5s;&#125;.g-container &#123;  width: 300px;  height: calc(var(--h) * 1px);&#125;ul &#123;  display: flex;  flex-direction: column;  animation: move calc(var(--speed) * var(--s)) steps(var(--s)) infinite;&#125;ul li &#123;  width: 100%;&#125;@keyframes move &#123;  0% &#123;    transform: translate(0, 0);  &#125;  100% &#123;    transform: translate(0, calc(var(--s) * var(--h) * -1px));  &#125;&#125;\n\n别看到上述有几个 CSS 变量就慌了，其实很好理解：\ncalc(var(--speed) * var(--s))：单次动画的耗时 * 轮播的个数，也就是总动画时长\nsteps(var(--s)) 就是逐帧动画的帧数，这里也就是 steps(6)，很好理解\ncalc(var(--s) * var(--h) * -1px)) 单个 li 容器的高度 * 轮播的个数，其实就是 ul 的总体高度，用于设置逐帧动画的终点值\n效果如下：\n\n这样，我们就得到了整体的结构，至少，整个效果是循环的。\n但是由于只是逐帧动画，所以只能看到切换，但是每一帧之间，没有过渡动画效果。所以，接下来，我们还得引入补间动画。\n利用补间动画实现两组数据间的切换我们需要利用补间动画，实现动态的切换效果。\n这一步，其实也非常简单，我们要做的，就是将一组数据，利用 transform，从状态 A 位移到 状态 B。\n把一开始提到的 逐帧动画 和这里这个 补间动画 结合一下，ul 的整体移动，和 li 的 单个移动叠在在一起：\n&lt;div class=&quot;g-container&quot;&gt;  &lt;ul style=&quot;--s: 6&quot;&gt;    &lt;li&gt;1111111&lt;/li&gt;    &lt;li&gt;2222222&lt;/li&gt;    &lt;li&gt;3333333&lt;/li&gt;    &lt;li&gt;4444444&lt;/li&gt;    &lt;li&gt;5555555&lt;/li&gt;    &lt;li&gt;6666666&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;\n\n:root &#123;  // 轮播的个数  --s: 6;  // 单个 li 容器的高度  --h: 36;  // 单次动画的时长  --speed: 1.5s;&#125;.g-container &#123;  width: 300px;  height: calc(var(--h) * 1px);&#125;ul &#123;  display: flex;  flex-direction: column;  animation: move calc(var(--speed) * var(--s)) steps(var(--s)) infinite;&#125;ul li &#123;  width: 100%;  animation: liMove calc(var(--speed)) infinite;&#125;@keyframes move &#123;  0% &#123;    transform: translate(0, 0);  &#125;  100% &#123;    transform: translate(0, calc(var(--s) * var(--h) * -1px));  &#125;&#125;@keyframes liMove &#123;  0% &#123;    transform: translate(0, 0);  &#125;  80%,  100%  &#123;    transform: translate(0, calc(var(--h) * -1px));  &#125;&#125;\n\n效果变为这样\n\n基于 逐帧动画 和 补间动画 的结合，我们几乎实现了一个轮播效果\n当然，有一点瑕疵，可以看到，最后一组数据，是从第六组数据 transform 移动向了一组空数据\n实际开发过轮播的同学肯定知道，这里，其实也很好处理，我们只需要在末尾，补一组头部的第一个数据即可\n这样我们就实现了开头那样的无限轮播效果啦~\n横向的也是可以的，只需改变位移方向即可实现\n掌握了这个技巧之后，你可以将它运用在非常多只需要简化版的轮播效果之上。\n完整代码codepen\n\n再简单总结一下，有实用也有缺点：\n\n利用 逐帧动画，实现整体的轮播的循环效果\n利用 补间动画，实现具体的 *状态A 向 状态B 的动画效果\n逐帧动画 配合 补间动画 构成整体轮播的效果\n通过向 HTML 结构末尾补充一组头部数据，实现整体动画的衔接\n通过 HTML 元素的 style 标签，利用 CSS 变量，填入实际的参与循环的 DOM 个数，可以实现 JavaScript 与 CSS 的打通\n注意iOS系统14以下的暂时不能兼容，如果要是兼容的话最好还是不要使用此方法\n跳转页面再回来可能会有错乱\n\n\n\n","slug":"animation-steps","date":"2022-11-26T08:01:04.000Z","categories_index":"css,animation","tags_index":"animation","author_index":"M"},{"id":"13f6ca6756a4b641116bd6f0d8205d5e","title":"Intersection Observer 交叉观察","content":"IntersectionObserver API 是现代浏览器提供的一种异步观察目标元素与祖先元素（或顶级文档视窗）交叉状态的方法。它可以用于实现懒加载图片、无限滚动、以及其他需要监听元素可见性的功能。\n基本概念在开始使用 IntersectionObserver 之前，我们需要了解几个基本概念：\n目标元素（Target Element）：你想要观察的元素。根元素（Root Element）：用来检测目标元素的可见性变化的容器元素，默认为浏览器视窗。阈值（Threshold）：触发回调函数的目标元素可见比例。\n为什么使用 IntersectionObserver传统上，我们会使用 scroll 事件监听元素的可见性变化。然而，这种方法有几个缺点：\n性能问题：滚动事件会频繁触发，从而导致性能问题。复杂的计算：需要手动计算元素的可见性。IntersectionObserver 可以解决这些问题：性能更好：IntersectionObserver 是异步的，不会频繁触发。简单易用：只需要定义一次观察逻辑，浏览器会处理所有计算。\n创建 IntersectionObserver 实例IntersectionObserver 是一个构造函数，我们需要先创建一个实例。构造函数接收两个参数：回调函数和可选配置对象。\nconst options = &#123;  root: null, // 默认为视窗  rootMargin: &#x27;0px&#x27;, // 视窗的外边距  threshold: 0.1 // 目标元素可见比例达到 10% 时触发回调&#125;;const ob = new IntersectionObserver(listener, options);\n\n定义回调函数回调函数在目标元素的可见性变化时被调用。它接收两个参数：entries 和 observer。\nconst listener = (entries, observer) =&gt; &#123;  entries.forEach(entry =&gt; &#123;    if (entry.isIntersecting) &#123;      console.log(&#x27;目标元素进入视窗&#x27;);      // 在此处理进入视窗后的逻辑    &#125; else &#123;      console.log(&#x27;目标元素离开视窗&#x27;);      // 在此处理离开视窗后的逻辑    &#125;  &#125;);&#125;;\n\n观察目标元素创建 IntersectionObserver 实例后，使用 observe 方法开始观察目标元素。\nconst imgs = document.querySelectorAll(&quot;img[data-src]&quot;);imgs.forEach((img)=&gt; &#123;  ob.observe(img)&#125;)\n\n停止观察如果不再需要观察某个元素，可以使用 unobserve 方法。\nobserver.unobserve(target);\n\n当不再需要 IntersectionObserver 实例时，可以调用 disconnect 方法停止观察所有目标元素。\nobserver.disconnect();\n\n完整例子：\n图片懒加载codepen\n","slug":"intersection-observer","date":"2022-10-15T10:45:36.000Z","categories_index":"javascript","tags_index":"Web API","author_index":"M"},{"id":"05fa6aa6edf6aaca899b62885f8a8f70","title":"简单的数字变化动画","content":"记录一个简单的数字变化动画\nfunction animation(&#123; from, to, duration = 1000, onUpdate &#125;) &#123;  let value = from;  const start = Date.now();  const speed = (to - from) / duration;  //让value值变化一点  function _run() &#123;    //1.改变value值    const t = Date.now() - start;    if (t &gt;= duration) &#123;      value = to;      onUpdate &amp;&amp; onUpdate(value);      return;    &#125;    value = from + t * speed;    onUpdate &amp;&amp; onUpdate(value);    //2.注册下一次变化    requestAnimationFrame(_run);  &#125;  _run();&#125;\n\n数字变化动画-codepen\n","slug":"count-number","date":"2022-09-18T04:59:08.000Z","categories_index":"javascript","tags_index":"javascript","author_index":"M"},{"id":"091a7e6c8b5ddb60fed53390d06e3bce","title":"CSS百分比padding与宽度自适应图片布局","content":"CSS百分比padding实现比例固定图片自适应布局。通过给盒子加resize属性模拟不同的屏幕宽度通过下面这个例子可以看到，无论屏幕宽度多宽，我们的图片比例都是固定的，自动进行适应，布局就显得非常有弹性。\n对于这种图片宽度100%容器，高度按比例的场景，padding-bottom的百分比值大小就是图片元素的高宽比。\n &lt;div class=&quot;box-img&quot; style=&quot;background-image: url(https://picsum.photos/id/193/382/214)&quot;&gt; .box-img &#123;  width: 100%;  height: 100%;  padding-bottom: 56.02%;  background-position: center;  background-repeat: no-repeat;  background-size: cover;&#125;\n\nimage-padding–codepen\n","slug":"image-padding","date":"2022-09-11T05:18:21.000Z","categories_index":"html&css","tags_index":"css","author_index":"M"},{"id":"eeb7b514e12d61eac9385751fe5aa156","title":"whistle抓包代理工具","content":"提起抓包工具，或许大家首先想到的是 Fiddler(Win) 和 Charles(Mac),这也是各自平台下优秀的抓包工具。然而，今天想推荐一款跟 平台无关的，不止于抓包的(还能调试)开发工具：Whistle。\nWhistle 是基于 Node 实现的跨平台web调试代理工具，可以用于查看、修改 HTTP、HTTPS、Websocket 的请求、响应，也可以作为 HTTP 代理服务器使用，不同于 Fiddler 通过断点修改请求响应的方式，Whistle 采用的是类似配置系统 hosts 的方式，一切操作都可以通过配置实现，支持域名、路径、正则表达式、通配符、通配路径等多种匹配方式，且可以通过 Node 模块扩展功能\n官网操作已经很详细了，就不赘述了。\nwhistle官网;\n","slug":"whistle","date":"2022-08-20T09:51:38.000Z","categories_index":"tools","tags_index":"tools","author_index":"M"},{"id":"41046c2c30390c7bbce15460a949ca7f","title":"0.5px边框的各方法对比总结","content":"做移动端开发的时候，如果边框直接设置 1px 的宽度，可能视觉上还是太粗无法满足设计师的要求。下面是我实现 0.5px 边框的几种方案。\n&lt;div class=&quot;box box1&quot;&gt;1px 边框&lt;/div&gt;&lt;div class=&quot;box box2&quot;&gt;0.5px 边框 阴影&lt;/div&gt;&lt;div class=&quot;box box3&quot;&gt;0.5px 边框 渐变&lt;/div&gt;&lt;div class=&quot;box box4&quot;&gt;0.5px 边框 transform-scale&lt;/div&gt;&lt;div class=&quot;box box5&quot;&gt;0.5px 边框 0.5px&lt;/div&gt;\n\n.box &#123;  width: 300px;  height: 50px;  border-radius: 8px;  margin-top: 10px;&#125;.box1 &#123;  border: 1px solid #000;&#125;.box2 &#123;  box-shadow: 0px 0px 0px 0.5px #000;&#125;.box3 &#123;  position: relative;&#125;.box3::after &#123;  content: &quot;&quot;;  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px;  background-image: linear-gradient(0deg, #000 50%, transparent 50%);&#125;.box4 &#123;  position: relative;&#125;.box4::after &#123;  content: &quot;&quot;;  width: 198%;  height: 198%;  border: 1px solid #000;  border-radius: 16px;  transform: scale(0.5);  transform-origin: 0 0;  position: absolute;  left: 0;  top: 0;  pointer-events: none;&#125;.box5 &#123;  border: 0.5px solid #000;&#125;\n\n总结：\n\n1、‌使用box-shadow属性‌：box-shadow属性允许设置小数值，可以用来模拟0.5px的边框效果。通过设置box-shadow的四个偏移量（水平偏移、垂直偏移、模糊半径和扩展半径）为0，而将边框颜色设置为所需的颜色，可以实现类似0.5px边框的视觉效果。\n\n\n\n\n\n\n\n\n\n1.通过设置box-shadow属性，可以模拟更细的边框效果。2.这种方法适用于需要更细边框的场景。 \n\n2、‌伪元素结合transform缩放‌：通过创建一个伪元素，设置其边框为1px，然后使用transform: scale(0.5)将其缩小到原来的一半，从而实现0.5px的边框效果。\n\n\n\n\n\n\n\n\n\n1.这种方法兼容性较好，适用于需要展示圆角的场景‌。2.伪元素覆盖上去后会影响下面盒子点击，注意加一下pointer-events: none;属性使得点击穿透。3.还有就是注意宽高设置200%的话，会比盒子宽高多一点，建议使用198%。4.圆角记得也要是原来的2倍哦！\n\n\n3、‌背景渐变‌：给容器设置伪元素，设置绝对定位，高度设置为1px，背景图设置为线性渐变，一半颜色，一半透明，可以实现0.5px边框的效果。这种适合元素之间的分割线，缺点是这种方法不能展示圆角‌。\n0.5border-codepen;\n","slug":"0.5border","date":"2022-08-06T06:21:59.000Z","categories_index":"html&css","tags_index":"css","author_index":"M"},{"id":"6bb0ba9791e24ded32fb982c8650bd52","title":"-webkit-tap-highlight-color","content":"iOS禁用点击透明黑色背景\n-webkit-tap-highlight-color: transparent\n","slug":"-webkit-tap-highlight-color","date":"2022-07-31T04:01:36.000Z","categories_index":"html&css","tags_index":"css","author_index":"M"},{"id":"ba99b041e2cc1b6cb56dc49d495fa921","title":"pointer-events","content":"pointer-events是一个CSS属性，它定义了在何种情况下元素可以成为鼠标事件（或触摸事件）的目标。这个属性可以控制元素是否可以被点击、是否可以触发鼠标事件，或者是否应该忽略鼠标事件，让事件传递给下面的元素。\n\npointer-events属性主要用于以下几种场景：\n\n\n\n\n\n\n\n\n\nNone: 元素不会成为鼠标事件的目标。例如，如果想让一个元素透明对用户的点击，可以将其pointer-events设置为none。Auto: 默认值。元素正常响应鼠标事件。\n\n\n移动端h5图片长按可以下载，但想禁用这个默认事件就可以使用此属性\n","slug":"pointer-events","date":"2022-07-30T05:01:28.000Z","categories_index":"html&css","tags_index":"css","author_index":"M"},{"id":"f7cd73850062e5beae0d458b739ec82c","title":"menu","content":"记录一个移动端导航栏menu切换效果\nmenu–codepen\n","slug":"menu","date":"2022-07-16T01:10:32.000Z","categories_index":"html&css","tags_index":"css","author_index":"M"},{"id":"efd7e953125c3177f72392a8f7d5efca","title":"backface-visibility","content":"记录一下之前backface-visibility写的翻转效果\n\n正面翻向背面的效果，有 4 个开发要点：\n\n\n\n\n\n\n\n\n\n使用 position: absolute 将两个 div (正面与背面) 重叠\n使用 transform: rotateY() 旋转 div\n使用 backface-visibility 隐藏背面\n使用 perspective 设定立体的透视深度\n\n\n\nbackface-visibility–codepen\n","slug":"backface-visibility","date":"2022-07-02T04:13:43.000Z","categories_index":"html&css","tags_index":"css","author_index":"M"},{"id":"7fc4ebdb86f13e06a2d2614342b4b921","title":"vscode自己常用插件","content":"记录一下我常用的vscode插件\n名称: px to rem &amp; rpx &amp; vw (cssrem)–把px转换成rem，或vw\n名称: Auto Close Tag\n名称: Auto Rename Tag\n名称: Beautify css&#x2F;sass&#x2F;scss&#x2F;less\n名称: Better Comments\n名称: Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code\n名称: Dracula Theme Official\n名称: Easy LESS\n名称: GitLens — Git supercharged\n名称: Highlight Matching Tag\n名称: Nested Comments\n名称: open in browser\n名称: Path Intellisense\n名称: Prettier - Code formatter\n名称: Vetur\n名称: vscode-icons\n名称: Vue Jumper\n名称: WXML - Language Service\n","slug":"vscode","date":"2022-05-01T03:57:13.000Z","categories_index":"","tags_index":"vscode","author_index":"M"}]